{
  "documents": [
    {
      "doc_id": "rb-2026-02-redis-evictions",
      "title": "Ранбук: Redis eviction и рассинхрон корзины/чекаута",
      "document_type": "runbook",
      "created_at": "2026-02-02",
      "content": "# Кратко\nЭтот ранбук для инцидентов, когда Redis (кластер Redis 7.2.4) начинает активно выкидывать ключи, тормозит или становится недоступен, и это приводит к странному поведению корзины и ошибкам при оформлении заказа.\n\nОсновные сервисы: cart-service, checkout-service\n\nКлючевые симптомы: всплеск 409 CART_VERSION_MISMATCH и 412 PRECONDITION_FAILED на POST /api/checkout/start, рост redis_evicted_keys_total, cache miss в cart-service выше 0.85.\n\n# Как выглядит норма\n- cart-service p95 80–140мс\n- checkout-service 409 почти 0\n- Redis: used_memory/maxmemory < 0.75, evicted_keys стабильный 0/мин\n- TTL корзины 900с (CART_CACHE_TTL_SECONDS=900), джиттер включен (CART_CACHE_TTL_JITTER_SECONDS=120)\n\n# Симптомы\n## Пользовательские\n- после обновления страницы корзина как будто теряет часть товаров\n- чекаут зацикливается с сообщением типа корзина изменилась, попробуйте снова\n- платеж висит в pending, но заказ не продвигается\n\n## Логи/ошибки\ncart-service:\n- redis.exceptions.ConnectionError: Error 111 connecting to redis.ecommerce-prod.svc:6379\n- CacheWriteSkipped size_bytes=221332 reason=value_too_large\n- cart_etag_source=redis etag_reset=true\n\ncheckout-service:\n- CartPreconditionFailed: missing If-Match\n- CART_VERSION_MISMATCH expected=18 got=17 cart_id=...\n\n# Где смотреть\nGrafana:\n- Platform / Redis / Cache Health\n- cart-service / Cache + DB\n- checkout-service / Funnel\n\nPrometheus алерты:\n- RedisEvictionsHigh: increase(redis_evicted_keys_total[5m]) > 500\n- CartVersionMismatchSpike: rate(http_responses_total{service=checkout-service,status=409}[5m]) > 5\n\n# Быстрый триаж (до 10 минут)\n1) Проверить масштаб: только корзина/чекаут или еще rate-limit, сессии, идемпотентность Stripe.\n2) Проверить Redis:\n`bash\nkubectl -n ecommerce-prod port-forward svc/redis 6379:6379\nredis-cli -p 6379 INFO memory | egrep 'used_memory_human|maxmemory_human|mem_fragmentation_ratio'\nredis-cli -p 6379 INFO stats | egrep 'evicted_keys|keyspace_hits|keyspace_misses'\nredis-cli -p 6379 CLUSTER INFO\n`\n3) Проверить размер значений корзины:\n- метрика cart_cache_value_size_bytes (p95)\n- если метрики нет, посмотреть логи на CacheWriteSkipped и size_bytes\n4) Проверить деплой за последний час: изменения сериализации корзины, рекомендаций, TTL/джиттера.\n\n# Митигирующие действия\nВыбирайте наименее рискованный вариант.\n\n## Вариант A: Временно обойти Redis для чтения корзины (предпочтительно)\nИдея: cart-service читает из Postgres, не пишет обратно в Redis.\n- CART_CACHE_BYPASS=true\n- CART_CACHE_WRITEBACK=false\n`bash\nkubectl -n ecommerce-prod set env deploy/cart-service CART_CACHE_BYPASS=true CART_CACHE_WRITEBACK=false\nkubectl -n ecommerce-prod rollout status deploy/cart-service\n`\nЦена: растет нагрузка на Postgres. Следите за numbackends и p95 checkout.\n\n## Вариант B: Снизить TTL и включить жесткий лимит размера\nЕсли Redis живой, но память упирается в maxmemory:\n- CART_CACHE_TTL_SECONDS=120\n- CART_CACHE_MAX_BYTES=131072\n`bash\nkubectl -n ecommerce-prod set env deploy/cart-service CART_CACHE_TTL_SECONDS=120 CART_CACHE_MAX_BYTES=131072\n`\nПримечание: большие корзины могут не кешироваться. Это ок, лучше чем трешинг.\n\n## Вариант C: Стабилизировать ETag\nЕсли основной ущерб от 409:\n- CART_ETAG_SOURCE=postgres (в checkout-service или общий модуль)\n- CHECKOUT_RETRY_ON_CART_MISMATCH=true (временно)\n`bash\nkubectl -n ecommerce-prod set env deploy/checkout-service CART_ETAG_SOURCE=postgres CHECKOUT_RETRY_ON_CART_MISMATCH=true\n`\n\n## Вариант D: Освободить память в Redis (последний шанс)\n1) Найти крупные ключи (осторожно, это может быть медленно):\n`bash\nredis-cli -p 6379 --scan --pattern 'cart:*' | head -n 2000 | xargs -n 50 redis-cli -p 6379 MEMORY USAGE\n`\n2) Удалить только явных монстров (корзины с раздувшимся payload):\n`bash\nredis-cli -p 6379 --scan --pattern 'cart:*' | head -n 500 | xargs -n 50 redis-cli -p 6379 DEL\n`\nРиск: кратковременный скачок нагрузки на Postgres.\n\n# Верификация и откат мер\n- redis_evicted_keys_total перестает расти\n- cache miss падает < 0.5 (после постепенного включения)\n- 409/412 возвращаются к базовому уровню\n\nПостепенно вернуть кеш:\n`bash\nkubectl -n ecommerce-prod set env deploy/cart-service CART_CACHE_BYPASS=false CART_CACHE_WRITEBACK=false\n# через 10–15 минут\nkubectl -n ecommerce-prod set env deploy/cart-service CART_CACHE_WRITEBACK=true CART_CACHE_TTL_SECONDS=900 CART_CACHE_TTL_JITTER_SECONDS=120\n`\n\n# Острые углы\n- Реплика-лаг: если чтение идет с реплик, ETag может как будто откатываться назад. Проверяйте INFO replication.\n- Смена формата ключей после деплоя: cart: vs cart2: даст 100 процентов miss без eviction.\n- Большие корзины (200+ позиций) могут превышать 256КБ. Должно быть CacheWriteSkipped.\n- Стадо при ре-гидратации: после bypass много корзин одновременно прогреваются. Без джиттера TTL будет синхронный шторм.\n\n# Ссылки\n- ADR-2025-03 Redis как кеш корзины\n- PM-2025-11 Redis eviction сломал чекаут\n- CL-2025-09 чеклист прод-деплоя (наблюдать Redis на изменениях кеша)"
    },
    {
      "doc_id": "rb-2026-01-stripe-webhook-backlog",
      "title": "Ранбук: backlog Stripe webhook и заказы в PAYMENT_PENDING",
      "document_type": "runbook",
      "created_at": "2026-01-14",
      "content": "# Кратко\nРанбук для случаев, когда Stripe webhooks начинают обрабатываться с задержкой, и заказы висят в PAYMENT_PENDING, возвраты не завершаются, или растет очередь stripe_webhook_queue_depth.\n\nГлавное: не пытайтесь чинить это срочным поллингом Stripe в горячем пути. Мы договорились, что вебхуки являются источником истины (ADR-2024-12). Поллинг допускается только как ре-консиляция.\n\nСервисы: payment-gateway (Node 18), checkout-service (FastAPI)\n\n# Симптомы\n## Пользовательские\n- Платеж подтвержден банком, но в нашем UI долго pending (больше 2 минут)\n- В Stripe Dashboard PaymentIntent succeeded, а у нас payment_status=PENDING\n- Refund requested висит без завершения\n\n## Метрики/алерты\n- stripe_webhook_queue_depth > 2000 10 минут\n- рост stripe_signature_fail_total\n- рост 5xx на POST /webhooks/stripe\n\n# Текущая схема\n1) Stripe шлет POST /webhooks/stripe на payment-gateway.\n2) payment-gateway проверяет подпись. Stripe API version закреплен 2023-10-16.\n3) Сырые события пишутся в Postgres таблицу stripe_events (PK event_id).\n4) Воркер обрабатывает события и обновляет payments/orders.\n5) checkout-service читает состояние из Postgres, не ходит в Stripe.\n\nИдемпотентность:\n- Уникальный stripe_events.event_id\n- Redis ключ stripe:evt:<event_id> TTL 7 дней (ускорение, не корректность)\n\n# Быстрый триаж\n1) В Stripe Dashboard посмотреть Delivery для endpoint webhooks/stripe.\nТиповые коды:\n- 400 invalid_signature\n- 413 payload too large\n- 429 throttling\n- 500 мы падаем до persistence\n\n2) Логи payment-gateway:\n`bash\nkubectl -n ecommerce-prod logs deploy/payment-gateway --since=15m | egrep 'invalid_signature|Signature|payload too large|OOMKilled|ETIMEDOUT|deadlock'\n`\n\n3) Проверить, что raw body не ломается.\nWebhook маршрут обязан быть на express.raw:\n`js\napp.post('/webhooks/stripe', express.raw({ type: 'application/json' }), handleStripeWebhook)\n`\nЕсли кто-то включил глобально express.json до этого маршрута, подписи начнут валиться.\n\n4) Проверить, что события вообще пишутся:\n`sql\nselect max(created_at) from stripe_events;\nselect count(*) from stripe_events where created_at > now() - interval '10 minutes';\n`\n\n# Митигирующие действия\n## A: invalid_signature (400)\nЦель: перестать отбрасывать валидные события.\n- Проверить STRIPE_WEBHOOK_SECRET актуален\n- Проверить ingress не модифицирует тело запроса\n- Если подозрение на регрессию парсинга, быстрый вариант: rollback payment-gateway на прошлый тег (например 1.38.2)\n`bash\nkubectl -n ecommerce-prod rollout undo deploy/payment-gateway\n`\n\n## B: 413 payload too large\nЧасто возникает при expand объектов (invoice lines) или неожиданно больших event payload.\n- Увеличить лимит тела на ingress для этого пути:\n`yaml\nnginx.ingress.kubernetes.io/proxy-body-size: 2m\n`\n- Проверить, что маршрут не проходит через промежуточный gateway с лимитом 1МБ.\n\n## C: Очередь растет, но ответы Stripe 2xx\nЗначит ingest ok, тормозит процессинг.\n- Увеличить WEBHOOK_MAX_CONCURRENCY умеренно (20 -> 50)\n- Отключить побочные эффекты на время: PAYMENTS_SEND_EMAILS=false\n- Перевести в режим persist+defer: WEBHOOK_DEFER_PROCESSING=true\n- Если очередь в Redis и Redis деградирует, временно: WEBHOOK_QUEUE_BACKEND=memory (не durable)\n\n## D: Postgres таймауты\nЕсли payment-gateway возвращает 500 из-за БД, Stripe будет ретраить, backlog на стороне Stripe тоже растет.\n- Уменьшить concurrency (WEBHOOK_MAX_CONCURRENCY=10)\n- Проверить connection exhaustion (см. RB-2024-11)\n- Если deadlock detected, смотреть последние миграции и индексы на stripe_events/payments\n\n# Безопасный replay\nОбычно Stripe ретраи достаточно. Ручной replay нужен только если мы когда-то вернули 2xx без записи в БД (это баг).\nЗапуск джобы:\n`bash\nkubectl -n ecommerce-prod create job --from=cronjob/stripe-webhook-replay stripe-webhook-replay-manual\n`\nПравила:\n- idempotent по event_id\n- терпит out-of-order типы\n\n# Проверка восстановления\n- В Stripe Dashboard последние доставки 2xx\n- stripe_webhook_queue_depth падает\n- В payments за последние 30 минут доля PENDING не растет\n\nSQL:\n`sql\nselect payment_status, count(*) from payments where created_at > now() - interval '30 minutes' group by 1;\nselect type, count(*) from stripe_events where created_at > now() - interval '30 minutes' group by 1 order by 2 desc;\n`\n\n# Edge cases\n- Out-of-order: refund события могут прийти до succeeded при ретраях\n- Дубликаты: Stripe может прислать один event_id несколько раз. Нельзя убирать уникальность, это сломает корректность.\n- Partial rollout секрета: часть подов принимает, часть отклоняет, будет каша из 2xx и 400.\n- Дрейф часов: подпись может падать по tolerance. Если только один узел ломается, проверьте NTP.\n\n# Ссылки\n- ADR-2024-12 вебхуки как источник истины\n- OB-2025-04 онбординг по платежам\n- PM-2025-08 дубликаты отгрузки при ретраях"
    },
    {
      "doc_id": "rb-2025-12-es-cluster-red",
      "title": "Ранбук: Elasticsearch red/yellow и деградация поиска",
      "document_type": "runbook",
      "created_at": "2025-12-03",
      "content": "# Кратко\nРанбук для ситуаций, когда Elasticsearch кластер становится yellow/red, появляются unassigned shards, растут 429 es_rejected_execution_exception, или индексирование отстает, и search-api начинает отдавать 503 SEARCH_UNAVAILABLE.\n\nСервисы: search-api, indexing-worker\n\nСтек: Elasticsearch 8.11.3 (3 master-eligible + 6 data nodes), индексы products-v3-*, алиас products_read (ADR-2025-02)\n\n# Норма\n- Cluster health green\n- search-api p95 120–220мс\n- Threadpool search/write очереди близко к 0\n- Kafka lag по catalog.product.changed < 50к и быстро догоняет\n- Диски data-node < 70 процентов\n\n# Симптомы\nsearch-api:\n- ConnectionTimeout\n- 429 es_rejected_execution_exception\n- index_not_found_exception: no such index [products_read]\n\nindexing-worker:\n- BulkIndexError: N documents failed\n- mapper_parsing_exception по attributes.*\n\n# Где смотреть\nGrafana:\n- Search / search-api\n- Platform / Elasticsearch / Cluster\n- Indexing / Kafka Lag\n\nАлерты:\n- ElasticsearchClusterRed\n- ElasticsearchDiskHighWatermark\n- SearchApi503Spike\n\n# Быстрый триаж\n1) Health:\n`bash\nkubectl -n ecommerce-prod port-forward svc/elasticsearch 9200:9200\ncurl -s http://localhost:9200/_cluster/health?pretty\n`\n2) Allocation explain:\n`bash\ncurl -s http://localhost:9200/_cluster/allocation/explain?pretty\n`\n3) Проверить алиас:\n`bash\ncurl -s http://localhost:9200/_cat/aliases/products_read?v\n`\n4) Threadpool:\n`bash\ncurl -s http://localhost:9200/_cat/thread_pool/search?v\ncurl -s http://localhost:9200/_cat/thread_pool/write?v\n`\n\n# Митигирующие действия\n## A: Disk watermark и unassigned shards\nЕсли причина disk_threshold:\n- Посмотреть старые индексы:\n`bash\ncurl -s 'http://localhost:9200/_cat/indices/products-v3-*?h=index,store.size,docs.count&s=index'\n`\n- Удалить явно устаревшие (ретеншн 14 дней). Важно: не удалить индекс, на который указывает products_read.\n`bash\ncurl -s 'http://localhost:9200/_cat/aliases/products_read?h=index'\ncurl -s -X DELETE 'http://localhost:9200/products-v3-2025.0*'\n`\nЕсли ILM сломан и не чистит, ручное удаление допустимо во время инцидента, но потом нужно восстановить ILM.\n\n## B: 429 и перегруз\nВключить деградацию в search-api:\n- SEARCH_ENABLE_AGGS=false\n- SEARCH_ENABLE_SPELLCHECK=false\n- SEARCH_MAX_CONCURRENCY=40 (вместо 80)\n`bash\nkubectl -n ecommerce-prod set env deploy/search-api SEARCH_ENABLE_AGGS=false SEARCH_ENABLE_SPELLCHECK=false SEARCH_MAX_CONCURRENCY=40\n`\nПараллельно уменьшить давление от индексатора.\n\n## C: Индексатор разогнал write\nЕсли lag огромный и write queue растет:\n- Пауза indexing-worker:\n`bash\nkubectl -n ecommerce-prod scale deploy/indexing-worker --replicas=0\n`\n- После стабилизации вернуть 1 реплику и меньший bulk:\n  - INDEXING_BULK_SIZE=250 (вместо 1000)\n  - INDEXING_FLUSH_INTERVAL_MS=750 (вместо 250)\n\n## D: Несовместимость mapping после деплоя\nЕсли search-api стал запрашивать поле, которого нет, или тип поменялся:\n- Быстро откатить search-api на совместимую версию\n- Либо временно вернуть products_read на старый индекс (атомарный switch алиаса):\n`bash\ncurl -s -X POST http://localhost:9200/_aliases -H 'Content-Type: application/json' -d '{\n  \"actions\": [\n    {\"remove\": {\"alias\": \"products_read\", \"index\": \"products-v3-2025.02.06\"}},\n    {\"add\": {\"alias\": \"products_read\", \"index\": \"products-v3-2025.01.30\"}}\n  ]\n}'\n`\nЕсли мешают двойные кавычки в примере, можно выполнить тот же запрос из файла.\n\n# Восстановление\n- Health green 10+ минут\n- search-api p95 < 250мс\n- Kafka lag по индексации начинает падать\n\nВозвращать indexing-worker постепенно: 1 реплика, маленький bulk, затем scale.\n\n# Острые углы\n- Hot shard: кластер зеленый, но один shard перегружен (популярная категория). Смотреть _cat/shards.\n- Master instability: master_not_discovered_exception. Не делайте ручной allocation до стабилизации мастеров.\n- Merge storm: слишком агрессивная индексация вызывает CPU spikes и замедляет поиск.\n- Type conflicts: attributes.size как строка в одних товарах и число в других приведет к mapper_parsing_exception.\n\n# Ссылки\n- ADR-2025-02 стратегия алиасов\n- API search-api v3\n- CL-2025-10 еженедельный ops чеклист (ILM/ретеншн)"
    },
    {
      "doc_id": "rb-2025-06-k8s-rollout-stuck",
      "title": "Ранбук: Rollout завис, CrashLoopBackOff, readiness не проходит",
      "document_type": "runbook",
      "created_at": "2025-06-21",
      "content": "# Кратко\nРанбук для случаев, когда деплой в Kubernetes зависает, новые поды в CrashLoopBackOff, или readiness probe не проходит и ingress начинает отдавать 502/503.\n\nКластеры: Kubernetes 1.29, namespaces ecommerce-prod / ecommerce-staging\nСервисы: checkout-service, cart-service, search-api (FastAPI 0.110), payment-gateway (Node 18)\n\n# Типовые симптомы\n- kubectl rollout status висит > 5 минут\n- Поды: CrashLoopBackOff, ImagePullBackOff, OOMKilled, Readiness probe failed\n- Пользовательские: всплеск 5xx после деплоя, частичные ошибки (mixed versions)\n\n# Быстрый триаж\n1) Статус rollout:\n`bash\nkubectl -n ecommerce-prod rollout status deploy/checkout-service\nkubectl -n ecommerce-prod get pods -l app=checkout-service -o wide\n`\n2) Describe проблемного пода:\n`bash\nkubectl -n ecommerce-prod describe pod <pod>\n`\nСмотреть Events: pull errors, probe failures, OOM.\n\n3) Логи текущие и предыдущие:\n`bash\nkubectl -n ecommerce-prod logs <pod> --previous --tail=200\nkubectl -n ecommerce-prod logs <pod> --tail=200\n`\n\n# Митигирующие сценарии\n## A: Readiness probe падает\nПроверить локально внутри пода:\n`bash\nkubectl -n ecommerce-prod exec -it <pod> -- sh -c 'wget -qO- http://127.0.0.1:8080/health/ready || true'\n`\nЕсли readiness включает внешние зависимости, решите, должна ли она быть строгой.\nМы поддерживаем READINESS_STRICT_DEPS=false для сервисов с fallback (например cart-service может жить на Postgres без Redis).\n\nВременный фикс для cart-service:\n`bash\nkubectl -n ecommerce-prod set env deploy/cart-service READINESS_STRICT_DEPS=false\n`\nВнимание: если readiness становится слишком мягкой, вы можете начать принимать трафик в деградированном состоянии. Это нормально только как временная мера.\n\n## B: CrashLoop из-за отсутствующего env/secret\nFastAPI валидирует settings и падает быстро.\nТиповые сообщения:\n- ValidationError: Settings.STRIPE_API_KEY Field required\n- KeyError по переменной\n\nДействия:\n- проверить секрет существует\n- сравнить имена ключей в Deployment и в коде\n- если не уверены, откатить (быстрее, чем патчить на горячую)\n`bash\nkubectl -n ecommerce-prod rollout undo deploy/checkout-service\n`\n\n## C: Schema drift (миграции не применились)\nСимптом: psycopg.errors.UndefinedColumn.\nДействия:\n1) Откатить сервис.\n2) Запустить миграцию джобой против primary Postgres (не через PgBouncer):\n`bash\nkubectl -n ecommerce-prod create job --from=cronjob/checkout-migrations checkout-migrations-manual\n`\n3) После применения снова деплоить.\n\n## D: OOMKilled\nСимптом: Last State Terminated OOMKilled.\nДействия:\n- временно увеличить memory limit и посмотреть, стабилизируется ли\n- если это регрессия (логирование больших payload, кеширование в памяти), откатить и чинить в ветке\n\n## E: ImagePullBackOff\nПричины:\n- тег не собран (ошибка GitHub Actions)\n- промоут ссылается на несуществующий SHA\n- сломан imagePullSecret\n\nФикс: быстро указать прошлый известный рабочий образ или откатить rollout.\n\n# Опасность частичного rollout (mixed versions)\nДаже если readiness проходит, смешанные версии могут ломать инварианты:\n- изменение формата Redis ключей cart: vs cart2:\n- checkout-service ожидает новые error_code от cart-service\n\nЕсли подозрение на несовместимость, выбирайте rollback, а не ожидание.\n\n# Проверка после мер\n- rollout завершился\n- ingress 5xx вернулся к базовому\n- по сервису нет новых ValidationError/UndefinedColumn\n\nСмоук:\n`bash\ncurl -sSf https://api.company.tld/healthz >/dev/null\ncurl -sSf https://api.company.tld/api/search/products?q=sneakers | head -n 5\n`\n\n# После инцидента\n- Добавить pre-deploy проверки: секреты, alembic head, наличие алиаса products_read\n- Пересмотреть readiness: liveness не должен ходить во внешние системы\n- Если причина связана с миграциями, связать с PM-2025-07"
    },
    {
      "doc_id": "rb-2024-11-postgres-conn-exhaustion",
      "title": "Ранбук: исчерпание подключений Postgres (too many clients)",
      "document_type": "runbook",
      "created_at": "2024-11-09",
      "content": "# Кратко\nРанбук для случаев, когда Postgres начинает отказывать в новых подключениях, или latency взлетает из-за очередей в пулах. Типовая ошибка: FATAL sorry, too many clients already.\n\nПричина чаще всего: сервисы обходят PgBouncer или увеличили pool/worker в деплое. Мы используем PgBouncer transaction pooling (ADR-2024-08).\n\n# Симптомы\n- Массовые 500 на checkout-service/cart-service/payment-gateway\n- Таймауты, зависания запросов\n\nЛоги FastAPI:\n- psycopg.OperationalError: FATAL sorry, too many clients already\n- sqlalchemy.exc.TimeoutError: QueuePool limit reached\n\nЛоги Node (pg):\n- remaining connection slots are reserved...\n\n# Архитектура\n- Primary Postgres (приложениям нельзя): postgres-primary.ecommerce-prod.svc:5432\n- PgBouncer (приложениям нужно): pgbouncer.ecommerce-prod.svc:6432\n- Миграции Alembic должны ходить в primary напрямую\n\n# Быстрый триаж\n1) Посчитать коннекты и топ-источники:\n`sql\nshow max_connections;\nselect count(*) as total from pg_stat_activity;\nselect application_name, usename, state, count(*)\nfrom pg_stat_activity\ngroup by 1,2,3\norder by count(*) desc\nlimit 15;\n`\nЕсли application_name пустой или дефолтный, это подозрение на неправильную строку подключения.\n\n2) Проверить idle in transaction:\n`sql\nselect pid, application_name, now() - xact_start as xact_age, query\nfrom pg_stat_activity\nwhere state = 'idle in transaction'\norder by xact_age desc\nlimit 20;\n`\n\n3) PgBouncer:\nЕсли доступен admin:\n`sql\nshow pools;\nshow stats;\n`\nСмотрите cl_waiting.\n\n# Митигирующие действия\n## A: Снизить параллелизм приложений (самое безопасное)\nДля FastAPI число воркеров умножает пул.\n- WEB_CONCURRENCY=2\n- DB_POOL_SIZE=10\n- DB_MAX_OVERFLOW=5\n\n`bash\nkubectl -n ecommerce-prod set env deploy/checkout-service WEB_CONCURRENCY=2 DB_POOL_SIZE=10 DB_MAX_OVERFLOW=5\nkubectl -n ecommerce-prod set env deploy/cart-service WEB_CONCURRENCY=2 DB_POOL_SIZE=10 DB_MAX_OVERFLOW=5\n`\nПодождать 2–3 минуты, проверить pg_stat_activity.\n\n## B: Вернуть сервисы на PgBouncer\nЕсли деплой поменял DATABASE_URL на primary:\n- Патчить env обратно на pgbouncer и перезапустить pods\n- Или откатить rollout\n\nЭто самый частый root cause резких всплесков.\n\n## C: Убить явно зависшие сессии (последний шанс)\nТолько если уверены, что это мусор (например тысячи idle in transaction от одного пода):\n`sql\nselect pg_terminate_backend(pid)\nfrom pg_stat_activity\nwhere application_name like 'checkout-service@%' and state='idle in transaction'\n  and now() - xact_start > interval '2 minutes';\n`\nРиск: упадут запросы, возможны частичные операции.\n\n## D: Включить rate limit для защиты БД\nЕсли система близка к коллапсу:\n- лимитировать /api/checkout/start и /api/cart/* на ingress\n- лучше 429 чем каскад 500\n- временно остановить indexing-worker\n\n# Восстановление\nНормально:\n- total connections < 70 процентов от max\n- PgBouncer cl_waiting близко к 0\n- p95 возвращается\n\n# Острые углы\n- Лики соединений: забыли закрывать session на исключениях\n- Неправильное использование sync и async engine (двойные пулы)\n- Prepared statements и session state ломаются в transaction pooling\n- Джобы (refund-reconciler, webhook workers) тоже потребляют коннекты, учитывайте их в анализе\n\n# Ссылки\n- ADR-2024-08 PgBouncer\n- RB-2025-06 rollout stuck (часто рядом)\n- PM-2025-07 про миграции через PgBouncer"
    },
    {
      "doc_id": "adr-2024-12-stripe-webhooks",
      "title": "ADR-2024-12: Stripe webhooks как источник истины по платежам",
      "document_type": "adr",
      "created_at": "2024-12-15",
      "content": "# Статус\nПринято (2024-12-15)\n\n# Контекст\nРаньше checkout-service делал активный поллинг Stripe (retrieve PaymentIntent) чтобы понять финальный статус. Это приводило к:\n- 429 Too Many Requests на пиках\n- гонкам: заказ pending при фактически успешном платеже\n- сложным retry/backoff в горячем пути и росту p95\n- слабой аудитируемости: поддержки нет каноничного журнала событий\n\nУ нас есть legacy Node сервис payment-gateway, который уже принимает Stripe webhooks, но его выход не считался авторитетным. По сути было два конкурирующих источника правды.\n\n# Решение\nСделать Stripe webhooks авторитетным источником переходов платежного статуса.\n- payment-gateway:\n  1) проверяет подпись\n  2) сохраняет сырое событие в Postgres\n  3) ставит в очередь внутреннюю обработку\n- checkout-service:\n  - не поллит Stripe в запросах пользователя\n  - обновляет payments и orders только по результатам обработанных webhook событий\n\nПоллинг допускается только как оффлайновая ре-консиляция (например ежедневная) и для ручного инструмента поддержки.\n\n# Дизайн\n## Версия Stripe API\nФиксируем версию на 2023-10-16 в payment-gateway и логируем ее как stripe_api_version.\n\n## Endpoint\n- POST /webhooks/stripe\n- Требование: тело запроса должно быть raw, без переформатирования JSON.\n- В payment-gateway для этого маршрута использовать express.raw.\n\n## Проверка подписи\n- env: STRIPE_WEBHOOK_SECRET\n- При неверной подписи отвечаем 400.\nТиповой лог: StripeSignatureVerificationError.\n\n## Persistence\nТаблица stripe_events хранит payload целиком (jsonb) для аудита и replay.\n\nСхема:\n`sql\ncreate table stripe_events (\n  event_id text primary key,\n  type text not null,\n  created_at timestamptz not null default now(),\n  payload jsonb not null,\n  processed_at timestamptz,\n  process_error text\n);\ncreate index stripe_events_type_created_at_idx on stripe_events (type, created_at desc);\n`\n\n## Процессинг\n- Воркер берет event_id, читает payload, применяет переходы в транзакции.\n- Идемпотентность: PK event_id и уникальность на связях с payments.\n\n## Порядок событий\nStripe не гарантирует порядок. Процессор обязан терпеть:\n- дубликаты\n- out-of-order, включая refund события до succeeded\n\nПравило: переходы по возможности монотонные, не откатывать платеж из SUCCEEDED в PENDING.\n\n## Поведение при сбоях\nЕсли payment-gateway не может записать событие в Postgres, должен вернуть 500, чтобы Stripe ретраил. Нельзя отдавать 2xx без записи.\n\n# Последствия\nПлюсы:\n- меньше Stripe API вызовов и меньше 429\n- единый журнал событий\n- ясное разделение ответственности\n\nМинусы/риски:\n- webhook ingestion становится критичным для финализации заказа\n- регрессия в raw-body обработке сразу приводит к зависшим pending\n- нужны алерты на очередь и подписи (см. RB-2026-01)\n\n# Альтернативы\n- оставить поллинг: отклонено\n- перенести вебхуки в checkout-service: отклонено из-за владения ключами\n- публиковать события в Kafka: отложено\n\n# Заметки\n- ingress лимит тела должен быть достаточным, иначе 413.\n- Redis используется как ускорение, но корректность держится на Postgres.\n- В PM-2025-08 выяснилось, что downstream consumers должны быть идемпотентны даже если ingestion идемпотентен."
    },
    {
      "doc_id": "adr-2025-03-redis-carts",
      "title": "ADR-2025-03: Redis как основной кеш для корзин (read-through + write-through)",
      "document_type": "adr",
      "created_at": "2025-03-11",
      "content": "# Статус\nПринято (2025-03-11)\n\n# Контекст\ncart-service — высоконагруженный сервис. На пиках чтение корзины становится одним из топ источников нагрузки на Postgres, что ухудшает чекаут. In-process кеш на подах пробовали, но:\n- прогрев разный на каждом поде\n- деплой сбрасывает кеш и вызывает шторм\n- память растет непредсказуемо\n\nRedis уже используется для сессий, rate-limit и идемпотентности платежей, поэтому логично применить его как общий кеш.\n\n# Решение\nИспользовать Redis как основной кеш для payload корзины, при этом Postgres остается источником истины.\n- read-through на GET\n- write-through на мутациях\n- TTL + джиттер\n- policy: allkeys-lfu\n\nЭто НЕ означает, что Redis становится системой записи.\n\n# Дизайн\n## Формат ключей\nКлюч должен быть стабильным:\n- cart:<user_id>:v<version>\n\n## TTL\n- CART_CACHE_TTL_SECONDS=900\n- CART_CACHE_TTL_JITTER_SECONDS=120\n\n## Сериализация\n- msgpack v2 (быстрее и меньше чем JSON)\n- payload включает cart_id, version, currency, items, минимальные totals\nИсключить:\n- расширенные рекомендации\n- профиль пользователя\n\n## Redis конфиг (prod baseline)\n`conf\nmaxmemory 18gb\nmaxmemory-policy allkeys-lfu\nactivedefrag yes\nlazyfree-lazy-eviction yes\n`\n\n## Поведение cart-service\nGET:\n- при hit возвращаем X-Cache: hit\n- при miss читаем из Postgres и пишем в Redis\n- при недоступном Redis: fallback на Postgres, X-Cache: bypass\n\nМутации:\n- транзакция в Postgres\n- инкремент version\n- запись нового payload в Redis\n- публикация cart.updated (для аналитики, не критично)\n\n## ETag и optimistic concurrency\ncart-service возвращает ETag, checkout-service передает If-Match.\nОжидание: 409 при несовпадении, клиент должен перезагрузить корзину.\n\nРиск: если ETag вычисляется из кешированного payload, eviction/rehydrate может повысить mismatch. Это позже подтвердилось в PM-2025-11.\n\n# Последствия\nПлюсы:\n- меньше Postgres read load\n- ниже latency\n\nМинусы:\n- Redis становится большим радиусом поражения: eviction шторм возвращает нагрузку в БД\n- риск раздувания payload\n- риск partial deploy при смене формата ключей\n\n# Альтернативы\n- Postgres-only с репликами: дороже и p95 хуже\n- Хранить корзины в Redis как источник истины: отклонено\n- Клиентский кеш: отклонено\n\n# Требования и follow-ups\n- добавить алерты на redis_evicted_keys_total и размер payload\n- добавить жесткий лимит CART_CACHE_MAX_BYTES и пропуск кеширования больших payload\n- ранбук на инциденты (RB-2026-02)\n\n# Примечание о противоречиях\nЭта ADR про производительность. Если Redis будет причиной повторяющихся инцидентов, возможен пересмотр: кешировать только минимальный набор (sku+qty) или вовсе уйти в Postgres+реплики. Это пока не принято, но обсуждалось после PM-2025-11."
    },
    {
      "doc_id": "adr-2025-02-es-aliasing",
      "title": "ADR-2025-02: Алиасы Elasticsearch и reindex без простоя",
      "document_type": "adr",
      "created_at": "2025-02-06",
      "content": "# Статус\nПринято (2025-02-06)\n\n# Контекст\nМаппинги Elasticsearch часто нужно менять (анализаторы, новые поля, типы). In-place изменения ограничены. Полный reindex каталога занимает часы. Раньше у нас был один индекс products-current, что делало деплои рискованными и плохо откатываемыми.\n\nНужно:\n- атомарный cutover\n- быстрый rollback\n- независимые релизы search-api и indexing-worker\n\n# Решение\nВводим read/write алиасы:\n- products_read\n- products_write\n\nКонкретные индексы: products-v3-YYYY.MM.DD\nindexing-worker пишет в products_write, search-api читает products_read. Во время миграций алиасы могут указывать на разные индексы.\n\n# Дизайн\n## Шаблон и ограничения\nTemplate: products-template-v3\nПравила:\n- attributes.* нормализовать, избегать field explosion\n- index.mapping.total_fields.limit=1000\n\nПример settings:\n`json\n{\n  \"number_of_shards\": 12,\n  \"number_of_replicas\": 1,\n  \"index.mapping.total_fields.limit\": 1000\n}\n`\n\n## Процесс cutover\n1) Создать новый индекс products-v3-<today>.\n2) Backfill:\n- предпочтительно из Postgres снапшота\n- запасной вариант: _reindex со старого\n3) Включить dual-write:\n- INDEX_DUAL_WRITE=true\n- INDEX_DUAL_WRITE_TARGET=products-v3-<today>\n4) Переключить products_read на новый индекс.\n5) Проверить query parity и doc counts.\n6) Переключить products_write и выключить dual-write.\n\n## Валидация\n- doc count в пределах 0.5 процента\n- 20 каноничных запросов дают близкие totals (+/- 5%)\n- нет query_shard_exception в логах\n\n## Rollback\nRollback = вернуть products_read на старый индекс. Это ключевой плюс.\n\n# Последствия\nПлюсы:\n- reindex без простоя\n- быстрый rollback\n\nМинусы:\n- доп storage во время dual-write\n- operational complexity: алиасы, ILM и ретеншн должны быть корректны\n- новый failure mode: products_read отсутствует или указывает на удаленный индекс => search-api падает index_not_found_exception (см. RB-2025-12)\n\n# Edge cases\n- Disk watermark: unassigned shards, алиасы не помогут\n- Type conflicts: смена типа поля приводит к mapper_parsing_exception\n- Analyzer changes: релевантность меняется, нужен sign-off продукта\n\n# Follow-ups\n- ILM должен покрывать products-v3-*.\n- Еженедельный чеклист проверяет алиасы и ретеншн.\n\n# Примечание\nВ 2025-12 был инцидент с red кластером из-за дисков. В контексте этой ADR важно: алиасы решают проблему миграций, но не решают проблему capacity и ретеншна."
    },
    {
      "doc_id": "adr-2024-08-pgbouncer",
      "title": "ADR-2024-08: PgBouncer в режиме transaction pooling для Postgres",
      "document_type": "adr",
      "created_at": "2024-08-22",
      "content": "# Статус\nПринято (2024-08-22)\n\n# Контекст\nСуммарное число подключений к Postgres стало неконтролируемым: web pods * workers * pool size + фоновые воркеры. На пиках это приводило к:\n- FATAL too many clients\n- каскадным таймаутам\n- деградации p95 из-за churn\n\nУвеличивать max_connections — не решение: растет память на backend и падает производительность.\n\n# Решение\nВводим PgBouncer в режиме transaction pooling для всего app трафика.\n- Приложения по умолчанию подключаются к PgBouncer (порт 6432)\n- Прямые подключения к primary Postgres (5432) только для миграций и админских задач\n\n# Дизайн\n## Базовые настройки PgBouncer (prod)\n`ini\npool_mode = transaction\nmax_client_conn = 5000\ndefault_pool_size = 50\nreserve_pool_size = 10\nserver_idle_timeout = 60\nquery_wait_timeout = 120\nignore_startup_parameters = extra_float_digits\n`\n\n## Конфиг сервисов\nFastAPI (SQLAlchemy 2.0 + psycopg):\n- DATABASE_URL на PgBouncer\n- маленький client pool чтобы не делать pool-on-pool:\n  - DB_POOL_SIZE=10\n  - DB_MAX_OVERFLOW=5\n\nNode payment-gateway (pg):\n- max=20\n- таймауты задавать на транзакцию, не через session state\n\n## Ограничения совместимости\nTransaction pooling ломает:\n- session-scoped prepared statements\n- temp tables между запросами\n- SET ROLE/SET search_path без повторного применения\n\nПолитика: если сервис требует session semantics, он должен обосновать исключение.\n\n## Мониторинг\n- PgBouncer cl_waiting, sv_active\n- Postgres numbackends\n- ошибки timeout waiting for server connection\n\n# Последствия\nПлюсы:\n- резкое снижение numbackends\n- стабильность p95\n\nМинусы:\n- PgBouncer становится критическим компонентом\n- возможны неожиданные баги библиотек\n- миграции должны идти мимо PgBouncer\n\n# План внедрения\n- staging на одном сервисе\n- миграция по одному сервису\n- в чеклист деплоя добавить проверку DATABASE_URL\n\n# Edge cases\n- PgBouncer saturation: latency растет даже при здоровом Postgres\n- деплой, случайно указывающий на primary, быстро выжигает max_connections\n- миграции через PgBouncer могут вести себя странно (это случилось в PM-2025-07)\n\n# Связанные документы\n- RB-2024-11 исчерпание подключений\n- PM-2025-07 миграции и schema drift\n- CL-2025-09 прод-деплой"
    },
    {
      "doc_id": "ob-2025-05-fastapi-local",
      "title": "Онбординг: локальная разработка FastAPI сервисов",
      "document_type": "onboarding",
      "created_at": "2025-05-05",
      "content": "# Цель\nПоднять локально checkout-service, cart-service, search-api с зависимостями (Postgres, Redis, Elasticsearch) и уметь прогонять тесты. Документ специально содержит неприятные детали: порты, переменные окружения, миграции, сиды.\n\n# Что у нас есть\n- checkout-service: FastAPI 0.110, Python 3.11, SQLAlchemy 2.0, psycopg\n- cart-service: FastAPI 0.110, Redis кеш\n- search-api: FastAPI 0.110, ES client 8.x\n- payment-gateway (Node 18) в этом гайде почти не трогаем\n\n# Пререквизиты\n- Docker Desktop 4.27+\n- Python 3.11.7\n- Poetry 1.8+\n\n# Запуск зависимостей\nИз папки infra:\n`bash\ndocker compose up -d postgres redis elasticsearch\ndocker compose ps\n`\nЭндпойнты:\n- Postgres localhost:5432 db ecommerce user app pass app\n- Redis localhost:6379 db 0\n- Elasticsearch http://localhost:9200 (без auth)\n\nЕсли конфликт портов, проще всего поменять ports в docker-compose и поправить env.\n\n# База и миграции\nКаждый сервис владеет своими миграциями. Обычно сначала гоняют checkout-service, потому что он создает таблицы orders/payments.\n\n`bash\ncd checkout-service\npoetry install\nexport DATABASE_URL=postgresql+psycopg://app:app@localhost:5432/ecommerce\npoetry run alembic upgrade head\n`\n\nТиповые проблемы:\n- Cant locate revision: репо не обновлено или DB сломана. Проще пересоздать локальную БД.\n- InsufficientPrivilege: используете не того юзера.\n\n# Запуск checkout-service\n`bash\ncd checkout-service\nexport DATABASE_URL=postgresql+psycopg://app:app@localhost:5432/ecommerce\nexport REDIS_URL=redis://localhost:6379/0\nexport PAYMENT_GATEWAY_URL=http://localhost:8090\nexport SERVICE_ENV=local\nexport STRIPE_API_KEY=sk_test_dummy\npoetry run uvicorn app.main:app --reload --port 8081\n`\nHealth:\n- GET /health/live\n- GET /health/ready\n\nВажно: STRIPE_API_KEY нужен только чтобы пройти валидацию settings, checkout-service не должен напрямую дергать Stripe.\n\n# Запуск cart-service\n`bash\ncd cart-service\npoetry install\nexport DATABASE_URL=postgresql+psycopg://app:app@localhost:5432/ecommerce\nexport REDIS_URL=redis://localhost:6379/0\nexport CART_CACHE_TTL_SECONDS=900\nexport READINESS_STRICT_DEPS=false\npoetry run uvicorn app.main:app --reload --port 8082\n`\nREADINESS_STRICT_DEPS=false локально рекомендован, потому что Redis часто рестартится.\n\n# Запуск search-api\n`bash\ncd search-api\npoetry install\nexport ELASTICSEARCH_URL=http://localhost:9200\nexport SERVICE_ENV=local\nexport SEARCH_INDEX_NAME=products-v3-local\npoetry run uvicorn app.main:app --reload --port 8083\n`\n\nИнициализация локального индекса:\n`bash\npython scripts/create_index.py --index products-v3-local\npython scripts/seed_products.py --count 500\n`\nЕсли видите index_not_found_exception по products_read, это потому что в проде используется алиас. Локально используйте SEARCH_INDEX_NAME или создайте алиас вручную.\n\n# Тесты\n`bash\npoetry run pytest -q\npytest -q -m integration\n`\nИнтеграционные тесты ждут Postgres/Redis/ES. Если зависают, проверьте что docker compose поднят.\n\n# Конвенции дебага\n- X-Request-Id прокидываем между сервисами\n- Ошибки в формате:\n  - error_code\n  - message\n  - request_id\n\n# Частые грабли\n- Poetry подхватил Python 3.12 и сломал pin зависимостей\n- ES mapping drift: проще снести локальный индекс и пересоздать\n- Порты: локально 8081/8082/8083, в контейнере 8080\n\n# Что читать дальше\n- API: cart-service v1, checkout-service v2, search-api v3\n- Ранбуки: Redis eviction, Stripe webhook backlog, ES red\n- Чеклист прод-деплоя"
    },
    {
      "doc_id": "ob-2025-04-payments",
      "title": "Онбординг: платежи и интеграция со Stripe (checkout-service + payment-gateway)",
      "document_type": "onboarding",
      "created_at": "2025-04-02",
      "content": "# Зачем этот документ\nПлатежи у нас распределены по двум сервисам:\n- checkout-service (FastAPI) оркестрирует заказ и инициирует платеж\n- payment-gateway (Node 18) владеет Stripe ключами и принимает вебхуки\n\nОсновные баги рождаются на стыках: идемпотентность, ретраи, переходы статусов.\n\n# Компоненты\n- checkout-service: создает orders/payments в Postgres\n- payment-gateway: создает PaymentIntent в Stripe, принимает webhooks\n- Postgres: таблицы orders, payments, stripe_events\n- Redis: ускорение идемпотентности и локи\n\n# Happy path\n1) Клиент вызывает POST /api/checkout/start с Idempotency-Key.\n2) checkout-service валидирует снапшот корзины через cart-service (If-Match).\n3) checkout-service пишет заказ (PAYMENT_PENDING) и платеж (PENDING).\n4) checkout-service вызывает payment-gateway internal API, тот создает PaymentIntent и возвращает client_secret.\n5) Клиент подтверждает карту.\n6) Stripe шлет webhooks.\n7) payment-gateway пишет stripe_events и обрабатывает.\n8) payment_status становится SUCCEEDED, checkout-service переводит order в PAID.\n\n# Инварианты\n## Idempotency обязательна\n- Для /api/checkout/start требуем Idempotency-Key.\n- payment-gateway должен возвращать тот же PaymentIntent при повторе того же ключа.\nЕсли клиент повторит запрос с новым ключом, можно получить дубль PaymentIntent (support боль).\n\n## Webhooks источник истины\nADR-2024-12: не поллим Stripe в горячем пути. Если вебхуки задержались, заказ может зависнуть в pending — это ожидаемо, чинить нужно ingestion.\n\n## Raw body\nПодпись Stripe проверяется по raw body. Если включить JSON parsing до проверки, будет invalid_signature.\n\n# Локальный запуск payment-gateway\n`bash\ncd payment-gateway\nnpm ci\nexport STRIPE_API_KEY=sk_test_...\nexport STRIPE_WEBHOOK_SECRET=whsec_...\nexport DATABASE_URL=postgres://app:app@localhost:5432/ecommerce\nexport REDIS_URL=redis://localhost:6379/0\nnpm run dev\n`\nПорт 8090.\n\n# Stripe CLI для локальных вебхуков\n`bash\nstripe listen --forward-to localhost:8090/webhooks/stripe\n`\nStripe CLI выдаст whsec, его надо положить в STRIPE_WEBHOOK_SECRET.\n\n# Диагностика типовых проблем\n## Stripe показывает succeeded, а у нас pending\n`sql\nselect max(created_at) from stripe_events;\nselect payment_status, provider_payment_id from payments where order_id = '<id>';\n`\nЕсли события приходят, но не обработались, смотрите stripe_events.process_error.\n\n## Дубли отгрузки\nСмотреть PM-2025-08. Даже если Stripe ingest идемпотентен, downstream consumers обязаны быть идемпотентными.\n\n## Refund застрял\nВозвраты асинхронные. Помимо вебхуков есть refund-reconciler (ежедневно). Если вебхук был пропущен, reconciler может догнать.\n\n# Edge cases\n- 3DS: PaymentIntent может быть requires_action долго, это не failure\n- Amount: все суммы в minor units\n- Валюты: поддерживаем USD и EUR. В тесте Stripe пропускает больше, но прод должен отклонять\n- Out-of-order webhooks: возможны при ретраях\n\n# Полезные документы\n- ADR-2024-12\n- RB-2026-01\n- API checkout-service v2\n- PM-2025-08 (идемпотентность внутренних событий)"
    },
    {
      "doc_id": "ob-2025-10-cicd-k8s",
      "title": "Онбординг: CI/CD и Kubernetes конвенции (GitHub Actions + Docker + K8s)",
      "document_type": "onboarding",
      "created_at": "2025-10-12",
      "content": "# Обзор\nДокумент про то, как изменения попадают в прод и как дебажить проблемы CI/деплоя. Это не учебник по K8s, а наши конкретные правила.\n\n# Окружения\n- staging: namespace ecommerce-staging, host staging-api.company.tld\n- prod: namespace ecommerce-prod, host api.company.tld\n\n# Образы\nКонвенция:\n- <service>:<git-sha>\n- <service>:v<semver>\nЗапрещено деплоить latest.\n\nПример: checkout-service:9f2c1a3, checkout-service:v2.14.0\n\n# GitHub Actions\nКаждый сервис:\n- ci.yml (PR)\n- release.yml (теги)\nПлатформа:\n- promote.yml (промоут в прод)\n\nТиповые шаги:\n- lint (ruff 0.4.x)\n- pytest\n- docker buildx\n- push в registry\n\n# Процесс деплоя\n1) merge в main -> auto deploy в staging\n2) smoke тесты\n3) запуск promote.yml с SHA\n4) мониторинг rollout + метрики 15 минут\n\n# K8s конвенции\n- liveness: /health/live (без внешних зависимостей)\n- readiness: /health/ready (может проверять БД, но осторожно)\n\nПорты:\n- FastAPI 8080 в контейнере\n- payment-gateway 8090\n\n# Дебаг деплоя\nБыстрый набор команд:\n`bash\nkubectl -n ecommerce-prod rollout status deploy/cart-service\nkubectl -n ecommerce-prod get pods -l app=cart-service\nkubectl -n ecommerce-prod describe pod <pod>\nkubectl -n ecommerce-prod logs <pod> --previous\n`\nЕсли rollout завис, см. RB-2025-06.\n\n# Миграции\nКритично: миграции должны ходить в primary Postgres, не через PgBouncer (ADR-2024-08, PM-2025-07).\nЕсли деплой добавляет колонку, и миграция не выполнилась, получите UndefinedColumn и CrashLoop.\n\n# Observability\n- /metrics для Prometheus\n- X-Request-Id в логах\n\nМинимальные дашборды после деплоя:\n- latency + 5xx\n- Postgres numbackends\n- Redis evicted_keys (если трогали кеш)\n- Stripe webhook queue (если трогали payment-gateway)\n- ES health (если трогали search)\n\n# Грабли\n- Partial rollout секретов Stripe: часть подов валит invalid_signature\n- Смена формата Redis ключей: резкий cache miss и рост нагрузки на БД\n- Алиас products_read отсутствует: search-api уходит в 503\n\n# Локальный k8s (опционально)\nkind:\n`bash\nkind create cluster --name ecommerce-dev\nkubectl create ns ecommerce-dev\nkubectl -n ecommerce-dev apply -f infra/k8s/dev/\n`\nЕсли ImagePull проблемы, загрузите локальный образ в kind.\n\n# Рекомендация по rollback\nЕсли после деплоя сразу пошел всплеск 5xx, rollback первым действием, дебаг вторым.\n`bash\nkubectl -n ecommerce-prod rollout undo deploy/checkout-service\n`\n\n# Ссылки\n- CL-2025-09 прод-чеклист\n- RB-2024-11 Postgres connections\n- RB-2026-02 Redis eviction\n- RB-2026-01 Stripe webhook backlog"
    },
    {
      "doc_id": "api-2025-11-cart-v1",
      "title": "API Spec: cart-service Public API (v1)",
      "document_type": "api_spec",
      "created_at": "2025-11-10",
      "content": "# Обзор\ncart-service владеет состоянием корзины. Postgres — источник истины. Redis — кеш производительности (ADR-2025-03). При падении кеша API должно работать (дороже по latency).\n\nBase path: /api/cart\nAuth: Bearer JWT\nИдемпотентность: обязательна на мутациях (Idempotency-Key)\nКонкурентность: optimistic через If-Match (ETag)\n\n# Заголовки\nRequest:\n- Authorization: Bearer <jwt>\n- Idempotency-Key: <uuid> (для POST/DELETE)\n- If-Match: W/<etag> (для мутаций)\n- X-Request-Id (опционально)\n\nResponse:\n- ETag: W/<etag>\n- X-Cache: hit|miss|bypass\n- X-Request-Id\n\n# Модель данных\nCart:\n- cart_id uuid\n- user_id uuid\n- version int\n- currency string (USD или EUR)\n- items array\n- totals subtotal_minor, tax_minor, total_minor\n- updated_at RFC3339\n\nCartItem:\n- sku string\n- qty int 1..99\n- unit_price_minor int\n- title optional\n\n# Формат ошибок\nЕдиный формат:\n`json\n{ 'error_code': 'CODE', 'message': 'text', 'request_id': '...' }\n`\n\nТиповые error_code:\n- CART_NOT_FOUND (404)\n- ITEM_NOT_FOUND (404)\n- INVALID_QTY (422)\n- INVALID_SKU (422)\n- CART_VERSION_MISMATCH (409)\n- PRECONDITION_FAILED (412)\n- IDEMPOTENCY_KEY_REUSE (409)\n- RATE_LIMITED (429)\n\n# Endpoints\n## GET /api/cart/{user_id}\nВозвращает корзину. По умолчанию пустая корзина возвращается как 200 с пустым списком, а не 404.\nQuery:\n- include_empty bool default true\n\nОтвет 200 пример:\n`json\n{\n  'cart_id': '3b3b...',\n  'user_id': '9a9a...',\n  'version': 17,\n  'currency': 'USD',\n  'items': [{'sku': 'SKU-123', 'qty': 2, 'unit_price_minor': 1299}],\n  'totals': {'subtotal_minor': 2598, 'tax_minor': 182, 'total_minor': 2780},\n  'updated_at': '2025-11-02T10:12:30Z'\n}\n`\n\n## POST /api/cart/{user_id}/items\nДобавить или обновить qty.\nHeaders: Idempotency-Key обязателен, If-Match обязателен.\nBody:\n`json\n{ 'sku': 'SKU-123', 'qty': 3 }\n`\nОшибки:\n- 409 CART_VERSION_MISMATCH если ETag устарел\n- 412 PRECONDITION_FAILED если If-Match отсутствует\n- 422 INVALID_QTY/INVALID_SKU\n\nПоведение идемпотентности:\n- Повтор того же ключа с тем же payload должен вернуть тот же результат.\n- Повтор того же ключа с другим payload -> 409 IDEMPOTENCY_KEY_REUSE.\n\n## DELETE /api/cart/{user_id}/items/{sku}\nУдалить позицию.\nHeaders: Idempotency-Key, If-Match обязательны.\nОшибки: 404 ITEM_NOT_FOUND.\n\n## POST /api/cart/{user_id}/clear\nОчистить корзину, version инкрементится.\nИспользуется UI и (опционально) checkout-service после успешного заказа.\n\n## GET /api/cart/{user_id}/items\nПагинация для аномально больших корзин (видели 500+ позиций из-за злоупотреблений API).\nQuery:\n- page_size int default 100 max 200\n- cursor string\nResponse:\n- items\n- next_cursor\n\n# Идемпотентность (внутри)\nПо умолчанию ключи храним в Redis:\n- idem:cart:<user_id>:<key> TTL 24h\nЕсли Redis недоступен, fallback на таблицу Postgres idempotency_keys.\n\n# Нюансы\n- qty=0 не принимаем, удаление только через DELETE. Раньше некоторые клиенты пытались использовать 0, это создавало тихие рассинхроны.\n- Unit price может устареть, финальный пересчет делает checkout-service (иначе PRICE_CHANGED).\n- Redis eviction может повышать mismatch rate, особенно если ETag считался из кешированного payload. Смотри RB-2026-02 и PM-2025-11.\n\n# Changelog\nv1.6 (2025-10) добавили /clear\nv1.7 (2025-11) добавили IDEMPOTENCY_KEY_REUSE"
    },
    {
      "doc_id": "api-2025-11-checkout-v2",
      "title": "API Spec: checkout-service Public API (v2)",
      "document_type": "api_spec",
      "created_at": "2025-11-18",
      "content": "# Обзор\ncheckout-service оркестрирует оформление заказа, создает order/payment в Postgres и инициирует платеж через payment-gateway. Финализация платежа идет по webhooks (ADR-2024-12).\n\nBase path: /api/checkout\nAuth: Bearer JWT\nИдемпотентность: обязательна для /start и refund\n\n# Заголовки\nRequest:\n- Authorization: Bearer <jwt>\n- Idempotency-Key: <uuid> (обязателен для /start)\n- X-Request-Id опционально\n\nResponse:\n- X-Request-Id\n- Retry-After иногда при 503\n\n# Формат ошибок\n`json\n{ 'error_code': 'CODE', 'message': 'text', 'request_id': '...' }\n`\nКоды:\n- CART_VERSION_MISMATCH (409)\n- PRICE_CHANGED (409)\n- ADDRESS_INVALID (422)\n- PAYMENT_PROVIDER_UNAVAILABLE (503)\n- PAYMENT_PENDING_TIMEOUT (409)\n- ORDER_NOT_FOUND (404)\n- ORDER_ALREADY_PAID (409)\n- IDEMPOTENCY_KEY_REUSE (409)\n\n# Статусы\norders.status: PAYMENT_PENDING, PAID, FULFILLING, FULFILLED, PAYMENT_FAILED, CANCELLED\npayments.payment_status: PENDING, SUCCEEDED, FAILED, CANCELED, REFUNDED\n\n# Endpoints\n## POST /api/checkout/start\nСоздает заказ и возвращает client_secret.\nBody:\n`json\n{\n  'user_id': 'uuid',\n  'cart_id': 'uuid',\n  'shipping_address_id': 'uuid',\n  'billing_address_id': 'uuid',\n  'currency': 'USD'\n}\n`\n\nШаги:\n1) Вызывает cart-service GET /api/cart/{user_id} и проверяет If-Match семантику (ETag).\n2) Делает пересчет цен (локально, без внешнего pricing сервиса).\n3) В транзакции пишет orders и payments.\n4) Дергает payment-gateway internal endpoint, создает PaymentIntent.\n\nОтвет 201:\n`json\n{\n  'order_id': 'uuid',\n  'status': 'PAYMENT_PENDING',\n  'payment': {\n    'provider': 'stripe',\n    'payment_intent_id': 'pi_...',\n    'client_secret': 'pi_..._secret_...'\n  }\n}\n`\n\nОшибки:\n- 409 CART_VERSION_MISMATCH если корзина изменилась\n- 409 PRICE_CHANGED если пересчет дал другие totals\n- 503 PAYMENT_PROVIDER_UNAVAILABLE если payment-gateway недоступен\n\nНюанс: если payment-gateway таймаутит, но успел создать PaymentIntent, повтор с тем же Idempotency-Key должен вернуть тот же intent. Если это ломается, будет дубль intent.\n\n## GET /api/checkout/orders/{order_id}\nПолные детали заказа и платежа.\n\n## GET /api/checkout/orders/{order_id}/status\nЛегкий endpoint для UI polling:\n`json\n{ 'order_id': '...', 'status': 'PAYMENT_PENDING', 'payment_status': 'PENDING' }\n`\nКешируется на edge 2 секунды, не использовать как источник корректности.\n\n## POST /api/checkout/orders/{order_id}/cancel\nОтмена неоплаченного заказа.\nПравила:\n- если payment_status=SUCCEEDED -> 409 ORDER_ALREADY_PAID\n- если pending старше 10 минут, отмена разрешена\n\n## POST /api/checkout/orders/{order_id}/refund\nАсинхронный возврат (обычно support tooling). Требует elevated scope.\nHeaders: Idempotency-Key обязателен.\nBody:\n`json\n{ 'amount_minor': 2780, 'reason': 'customer_request' }\n`\nОтвет: 202 accepted.\n\n# Идемпотентность\n- Для /start ключ хранится в таблице checkout_idempotency с unique (user_id, key).\n- Повтор с другим cart_id/address_id -> IDEMPOTENCY_KEY_REUSE.\n\n# Observability\nМетрики:\n- checkout_start_total\n- checkout_cart_mismatch_total\n- payment_provider_errors_total\n- orders_payment_pending_total\n\nЛоги:\n- order_id, user_id, cart_id, provider_payment_id, request_id\n\n# Edge cases\n- Pending слишком долго: UI может предложить поддержку, backend может вернуть PAYMENT_PENDING_TIMEOUT\n- Out-of-order Stripe события: успех может прийти после cancel. Тогда политика: предпочитать SUCCEEDED и затем инициировать refund, если нужно.\n- Currency mismatch: если валюта корзины не совпала с запросом, возвращаем 422 CURRENCY_MISMATCH\n- 304 от cart-service: checkout-service не должен доверять только UI totals, должен сверить со снапшотом\n\n# Связанные документы\n- ADR-2024-12\n- RB-2026-01\n- OB-2025-04"
    },
    {
      "doc_id": "api-2025-11-search-v3",
      "title": "API Spec: search-api Public API (v3)",
      "document_type": "api_spec",
      "created_at": "2025-11-22",
      "content": "# Обзор\nsearch-api предоставляет поиск товаров поверх Elasticsearch. Индексы меняются через алиасы (ADR-2025-02). Во время reindex результаты могут слегка отличаться, но контракт API стабилен.\n\nBase path: /api/search\nAuth: опционально (анонимный поиск разрешен), JWT нужен для персонализации\n\n# Заголовки\nRequest:\n- X-Request-Id (опционально)\n- Accept-Language (опционально)\n\nResponse:\n- X-Request-Id\n- X-Search-Degraded: true|false\n\n# Ошибки\n`json\n{ 'error_code': 'CODE', 'message': 'text', 'request_id': '...' }\n`\nКоды:\n- INVALID_FILTER (400)\n- INVALID_SORT (400)\n- SEARCH_UNAVAILABLE (503)\n- SEARCH_RATE_LIMITED (429)\n\n# Endpoints\n## GET /api/search/products\nQuery:\n- q string (пусто = trending)\n- page int default 1\n- page_size int default 24 max 100\n- filters repeatable key:value (brand, category, price_min, price_max, in_stock)\n- sort relevance|price_asc|price_desc|newest\n- include_facets bool default true\n\nОтвет 200:\n`json\n{\n  'total': 1234,\n  'page': 1,\n  'page_size': 24,\n  'results': [\n    { 'sku': 'SKU-123', 'title': 'Sneaker X', 'price_minor': 1299, 'currency': 'USD', 'score': 12.3 }\n  ],\n  'facets': {\n    'brand': [{'value': 'acme', 'count': 120}],\n    'category': [{'value': 'shoes', 'count': 900}]\n  }\n}\n`\n\n## GET /api/search/suggest\nQuery:\n- q required\n- limit default 8 max 20\nОтвет:\n`json\n{ 'suggestions': ['sneakers', 'sneaker cleaner'] }\n`\n\n# Таймауты\nElasticsearch client:\n- connect 50мс\n- request 150мс\nРетраи отключены, чтобы не усиливать перегруз. Если ES отвечает 429, мы возвращаем 503 SEARCH_UNAVAILABLE с retry_after_seconds=2.\n\n# Degraded mode\nПри перегрузе ES или health yellow/red:\n- SEARCH_ENABLE_AGGS=false (убираем facets)\n- SEARCH_ENABLE_SPELLCHECK=false\n- SEARCH_MAX_CONCURRENCY=40\n\nТогда:\n- facets отсутствуют\n- X-Search-Degraded=true\n\n# Алиасы\nЧитаем из products_read.\nЕсли алиас отсутствует или указывает на удаленный индекс, ES вернет index_not_found_exception, search-api отдаст 503.\n\n# Нюансы\n- q пустой: trending кешируется на 60с\n- неизвестный filter key: 400 INVALID_FILTER\n- Accept-Language неподдерживаемый: используем default analyzer\n- facets во время dual-write могут быть неидеальны, это допустимо\n\n# Rate limit\nНа edge:\n- 60 rpm на IP для /products\n- 120 rpm на IP для /suggest\nПри лимите: 429 SEARCH_RATE_LIMITED, Retry-After: 5\n\n# Observability\n- search_requests_total\n- search_latency_seconds_bucket\n- es_rejections_total\n- search_degraded_mode_enabled (gauge)\n\n# Примеры\n`bash\ncurl 'https://api.company.tld/api/search/products?q=sneakers&page=1&page_size=24&filters=brand:acme&sort=relevance'\ncurl 'https://api.company.tld/api/search/suggest?q=snea&limit=8'\n`\n\n# Связанные документы\n- ADR-2025-02\n- RB-2025-12\n- CL-2025-10"
    },
    {
      "doc_id": "pm-2025-11-redis-evictions",
      "title": "Постмортем PM-2025-11: Redis eviction привел к ошибкам чекаута",
      "document_type": "postmortem",
      "created_at": "2025-11-30",
      "content": "# Summary\n2025-11-29 Redis в ecommerce-prod вошел в режим устойчивого memory pressure, начались интенсивные eviction и скачки latency команд. Так как cart-service активно использует Redis (ADR-2025-03), а checkout-service опирается на ETag/If-Match для согласованности, eviction шторм вызвал всплеск 409 CART_VERSION_MISMATCH и 412 PRECONDITION_FAILED на /api/checkout/start.\n\nДанные корзины не потеряны (источник истины Postgres), но конверсия просела примерно на 47 минут.\n\n# Impact\n- 2025-11-29 09:12–09:59 UTC\n- 12.4 процента запросов /api/checkout/start вернули 409/412\n- p95 checkout вырос с 220мс до 780мс\n- p95 cart-service вырос с 120мс до 410мс\n\n# Detection\nСработали алерты RedisEvictionsHigh и CartVersionMismatchSpike.\nНа дашборде Redis было видно used_memory почти равен maxmemory (18GB), evicted_keys рос.\n\n# Timeline\n- 09:12 алерт на eviction\n- 09:16 рост 409/412 и жалобы продукта\n- 09:22 включили CART_CACHE_BYPASS=true и отключили writeback\n- 09:26 Postgres нагрузка выросла, но удержалась < 75 процентов CPU\n- 09:31 удалили часть oversized ключей (как крайняя мера)\n- 09:38 подготовили hotfix по payload\n- 09:45 постепенно включили кеш обратно\n- 09:59 метрики вернулись к норме\n\n# Root cause\nУтром релизнули фичу рекомендаций в корзине. Реализация сохранила расширенные рекомендации прямо в кешированный payload корзины. Средний размер значения cart:* вырос примерно в 6 раз (с ~30КБ до ~180КБ, p95 > 220КБ).\n\nRedis policy allkeys-lfu не смог спасти ситуацию при упоре в maxmemory: ключи выкидывались и сразу создавались заново. Дополнительно на части путей TTL выставлялся без джиттера, что синхронизировало истечения.\n\nВажно: ETag вычислялся из кешированного payload в одном из путей (особенно при rehydrate), поэтому churn усиливал mismatch.\n\n# Contributing factors\n- Не было лимита размера кешируемого payload\n- Нагрузочные тесты не включали shape рекомендаций\n- TTL jitter применялся не везде\n- checkout-service не делал retry на mismatch (считал 409 фатальным)\n\n# Resolution\n- Временно bypass Redis для чтения корзины\n- Частичная ручная чистка oversized ключей\n- Hotfix: хранить в кеше только sku рекомендаций, не весь объект\n- Постепенное возвращение кеша\n\n# Что было хорошо\n- Фича-флаг CART_CACHE_BYPASS уже существовал\n- PgBouncer защитил Postgres от коллапса при росте read load\n\n# Что было плохо\n- Оптимизация производительности превратилась в correctness-adjacent проблему\n- Не было мониторинга по размеру значений\n\n# Action items\n1) Ввести CART_CACHE_MAX_BYTES=131072 и пропуск кеширования при превышении\n2) Добавить метрику cart_cache_value_size_bytes (p50/p95) и алерт\n3) Протестировать TTL jitter единообразно, покрыть unit тестом\n4) Добавить в checkout-service одноразовый retry на CART_VERSION_MISMATCH\n5) Дополнить ADR-2025-03 запретом кешировать expanded metadata\n\n# Противоречие с ADR\nADR-2025-03 предполагала, что Redis влияет только на latency и Postgres является fallback. На практике eviction шторм поднял mismatch и ударил по чекауту. Это не означает, что Redis нельзя использовать, но означает, что нельзя кешировать тяжелые payload и нельзя строить ETag на нестабильном представлении.\n\n# Ссылки\n- ADR-2025-03\n- RB-2026-02"
    },
    {
      "doc_id": "pm-2025-07-schema-drift",
      "title": "Постмортем PM-2025-07: деплой checkout-service сломался из-за не примененной миграции",
      "document_type": "postmortem",
      "created_at": "2025-07-19",
      "content": "# Summary\n2025-07-18 задеплоили checkout-service v2.9.0, который ожидал колонку orders.applied_promotions. Миграция Alembic не применилась (джоба упала), но promote пайплайн не зафейлился. Новые поды начали отдавать 500 с UndefinedColumn.\n\n# Impact\n- 2025-07-18 14:03–14:24 UTC\n- POST /api/checkout/start: ~68 процентов 500\n- GET /api/checkout/orders/{id}: 500 для заказов, созданных в окне\n\n# Detection\n- Checkout5xxSpike\n- Логи: psycopg.errors.UndefinedColumn: column orders.applied_promotions does not exist\n\n# Timeline\n- 14:03 promote завершился\n- 14:05 алерт\n- 14:10 откат на v2.8.3\n- 14:18 ручной запуск миграции\n- 14:24 стабилизация\n\n# Root cause\nМиграционная джоба использовала application DATABASE_URL, который указывает на PgBouncer. PgBouncer работает в transaction pooling (ADR-2024-08). Миграция использовала advisory lock и ожидала session-level стабильность. Джоба завершилась с non-zero.\n\nДальше два усугубляющих решения:\n- шаг миграции в promote был continue-on-error=true\n- не было проверки что alembic head действительно применен\n\nВ итоге деплой продолжился, код начал обращаться к несуществующей колонке.\n\n# Contributing factors\n- В staging миграции ходили напрямую в primary, поэтому проблему не поймали.\n- Логи миграции не отображались в сводке promote.\n- Не было preflight проверки схемы.\n\n# Resolution\n- Откат rollout\n- Ручной запуск миграций против primary Postgres:\n`bash\nkubectl -n ecommerce-prod create job --from=cronjob/checkout-migrations checkout-migrations-manual\nkubectl -n ecommerce-prod logs job/checkout-migrations-manual\n`\n- Проверка наличия колонки:\n`sql\nselect column_name from information_schema.columns where table_name='orders' and column_name='applied_promotions';\n`\n\n# Что было хорошо\n- Откат прошел быстро\n- Диагноз был очевиден по логам\n\n# Что было плохо\n- Пайплайн скрывал ошибку миграции\n- Нарушили собственную ADR про миграции мимо PgBouncer\n\n# Action items\n1) Убрать continue-on-error из миграционного шага\n2) Добавить gate: alembic current == head\n3) Ввести DATABASE_URL_PRIMARY для миграций во всех средах\n4) Добавить в promote вывод логов миграций в summary\n5) Обновить онбординг CI/CD и чеклист прод-деплоя\n\n# Нюанс\nИногда миграции случайно проходят через PgBouncer и кажется что это работает. Но любая миграция, зависящая от session state, может падать нестабильно. Дебаг такого поведения дороже, чем явное правило: миграции всегда через primary.\n\n# Ссылки\n- ADR-2024-08\n- RB-2025-06"
    },
    {
      "doc_id": "pm-2025-08-duplicate-fulfillment",
      "title": "Постмортем PM-2025-08: ретраи Stripe webhooks привели к дубликатам отгрузки",
      "document_type": "postmortem",
      "created_at": "2025-08-10",
      "content": "# Summary\n2025-08-09 краткая нестабильность payment-gateway привела к ретраям Stripe webhooks. Входящие Stripe события были идемпотентны по event_id, но downstream consumer fulfillment-dispatcher оказался не идемпотентен по нашему internal событию orders.paid. В результате часть заказов ушла в отгрузку дважды.\n\nВажно: клиентов не списало дважды, проблема была в логистике и нотификациях.\n\n# Impact\n- 2025-08-09 16:22–16:41 UTC\n- 183 заказа получили duplicate dispatch\n- 61 дубль shipping label\n- 9 упаковок начали готовить дважды, остановили до pickup\n\n# Detection\n- FulfillmentDuplicateDispatchSpike\n- тикеты поддержки: два трек-номера\n- алерт на рост 5xx по /webhooks/stripe и рост stripe_webhook_queue_depth\n\n# Timeline\n- 16:22 payment-gateway рестартится (OOMKilled)\n- 16:24 Stripe ретраит payment_intent.succeeded\n- 16:26 payment-gateway восстановился\n- 16:31 dispatcher отправляет заказы, появляются дубли\n- 16:34 oncall паузит fulfillment-dispatcher\n- 16:37 запускаем скрипт дедупликации\n- 16:41 стабилизация\n\n# Root cause\nДве проблемы:\n1) В payment-gateway был включен флаг LOG_WEBHOOK_PAYLOADS=true (оставили после отладки). Логирование полного payload на INFO привело к росту памяти и OOMKilled.\n2) Внутренняя цепочка transitions не была полностью идемпотентна. Один воркер обработал событие и поставил payment_status=SUCCEEDED, второй воркер повторно прошел путь после transient DB timeout и повторно эмитнул orders.paid, потому что не было уникального ограничения на (order_id, transition).\n\nfulfillment-dispatcher предполагал exactly-once и не проверял уникальность order_id при dispatch.\n\n# Resolution\nСразу:\n- scale fulfillment-dispatcher в 0\n- отмена дублей в warehouse API\n- hotfix checkout-service: эмитить orders.paid только если update реально меняет payment_status\n\nСтабилизация:\n- отключили LOG_WEBHOOK_PAYLOADS и перезадеплоили payment-gateway\n- временно снизили WEBHOOK_MAX_CONCURRENCY\n\n# Corrective actions\n1) Добавить unique constraint:\n`sql\nalter table order_transitions add constraint order_transition_unique unique (order_id, transition_name);\n`\n2) Сделать fulfillment-dispatcher идемпотентным:\n- unique по order_id\n- при дубле логировать и ack без действий\n3) Добавить алерт на OOMKilled payment-gateway\n4) Обновить RB-2026-01 предупреждением про payload logging\n5) Ввести правило в гайдлайнах: все consumers должны предполагать at-least-once\n\n# Что было хорошо\n- Быстро остановили downstream и ограничили радиус\n- Stripe ingestion не создал двойных списаний\n\n# Что было плохо\n- Debug флаги не отделены от прод-настроек\n- Идемпотентность была неполной (внутренние события)\n\n# Дополнительное противоречие\nADR-2024-12 делал ставку на вебхуки. После этого инцидента обсуждался fallback поллинг для VIP заказов. Это НЕ принято как стандартный путь, но появился экспериментальный флаг PAYMENTS_FORCE_POLLING_FALLBACK (включать только по согласованию, иначе можно усугубить 429 на Stripe).\n\n# Ссылки\n- ADR-2024-12\n- RB-2026-01\n- OB-2025-04"
    },
    {
      "doc_id": "cl-2025-09-prod-deploy",
      "title": "Операционный чеклист CL-2025-09: прод-деплой core сервисов",
      "document_type": "checklist",
      "created_at": "2025-09-01",
      "content": "# Назначение\nЧеклист для промоута релизов в прод для checkout-service, cart-service, search-api, payment-gateway. Он строгий, потому что большинство аварий было из-за мелочей: env vars, миграции, формат кеша.\n\n# Перед promote\n1) Артефакт\n- определить SHA образа и релиз-ноты\n- убедиться, что staging крутит тот же образ\n- CI прошел на merge commit\n\n2) Просмотреть diff на острые темы\n- миграции alembic\n- Redis ключи/сериализация\n- ES mapping/template\n- Stripe webhook изменения\n- новые env переменные (pydantic Settings)\n\n3) Миграции\n- миграционная джоба должна использовать primary Postgres, не PgBouncer\n- в staging: alembic current == head\n- если миграция тяжелая (индексы на больших таблицах), планировать off-peak или pre-run\n\n4) План отката\nВ issue записать:\n- на какой образ откатываемся\n- кто делает rollback\n- какой сигнал будет триггером отката (например 5xx spike, конверсия, алерты)\n\n# Во время promote\n5) Запуск\n- использовать promote workflow, не kubectl apply руками\n\n6) Мониторить rollout\n`bash\nkubectl -n ecommerce-prod rollout status deploy/<service>\nkubectl -n ecommerce-prod get pods -l app=<service>\n`\nЕсли > 5 минут зависло, см. RB-2025-06.\n\n7) Мониторить дашборды 15 минут\nМинимум:\n- latency и 4xx/5xx\n- Postgres numbackends\n- Redis evicted_keys (если трогали кеш)\n- Stripe webhook queue (если трогали payment-gateway)\n- ES health (если трогали search)\n\n8) Smoke тесты\n- корзина: add/remove + refresh, проверить что не пошли неожиданные 409\n- чекаут: /api/checkout/start с Idempotency-Key, повтор тем же ключом возвращает тот же order_id\n- поиск: базовый запрос, facets (если не degraded)\n- платежи: в staging тестовый платеж и проверить stripe_events\n\n# После деплоя\n9) Error budget\nЕсли burn ускорился, даже при малых абсолютных 5xx, остановиться и расследовать.\n\n10) Логи\nИскать:\n- ValidationError\n- UndefinedColumn\n- redis.exceptions\n- StripeSignatureVerificationError\n- index_not_found_exception\n\n11) Изменения вокруг Redis\nЕсли меняли кеш корзины:\n- наблюдать размеры payload и eviction минимум 30 минут\n- быть готовым включить CART_CACHE_BYPASS (RB-2026-02)\n\n# Экстренный rollback\nОткат если:\n- 5xx скачок сразу после релиза\n- просела конверсия чекаута\n- сломалась проверка подписи вебхуков\n- schema mismatch\n\nКоманды:\n`bash\nkubectl -n ecommerce-prod rollout undo deploy/checkout-service\nkubectl -n ecommerce-prod rollout undo deploy/cart-service\nkubectl -n ecommerce-prod rollout undo deploy/search-api\nkubectl -n ecommerce-prod rollout undo deploy/payment-gateway\n`\n\n# Примечания\n- Не включать LOG_WEBHOOK_PAYLOADS в прод без явного согласования (PM-2025-08)\n- Feature flag подход предпочтителен для рискованных изменений\n- Partial rollout секретов Stripe недопустим: при ротации нужно быстро прокрутить все поды"
    },
    {
      "doc_id": "cl-2025-10-weekly-ops",
      "title": "Операционный чеклист CL-2025-10: еженедельные проверки платформы",
      "document_type": "checklist",
      "created_at": "2025-10-06",
      "content": "# Назначение\nПрофилактический чеклист (45–60 минут) чтобы ловить медленные деградации: диски, очереди, ретеншн, коннекты, секреты. Это не инцидентный процесс.\n\n# 1) Postgres\n- проверить количество коннектов и долгие запросы\n`sql\nselect count(*) from pg_stat_activity;\nselect pid, now()-query_start as age, state, query\nfrom pg_stat_activity\nwhere state <> 'idle'\norder by age desc\nlimit 10;\n`\n- посмотреть bloat на cart_items и stripe_events, планировать maintenance если растет\n\n# 2) PgBouncer\n- убедиться, что сервисы ходят через PgBouncer (application_name и endpoint)\n- смотреть cl_waiting и sv_active\nЕсли видите много прямых подключений к primary, открыть тикет: это предвестник RB-2024-11.\n\n# 3) Redis\n- used_memory и eviction\n- размер payload корзины (cart_cache_value_size_bytes)\nЕсли eviction растет в обычном трафике:\n- подозрение на oversized values\n- отсутствие TTL jitter\n- внезапный рост трафика\n\nПримечание: Redis уже ломал чекаут (PM-2025-11).\n\n# 4) Elasticsearch\n- health green\n- диски ниже watermark\n- алиас products_read существует\n`bash\ncurl -s http://elasticsearch:9200/_cluster/health?pretty\ncurl -s http://elasticsearch:9200/_cat/aliases/products_read?v\ncurl -s http://elasticsearch:9200/_cat/indices/products-v3-*?h=index,store.size,docs.count&s=index\n`\nЕсли индексы старше 14 дней не удаляются, ILM сломан и это вопрос времени до disk watermark.\n\n# 5) Stripe webhooks\n- stripe_webhook_queue_depth на базовом уровне\n- stripe_signature_fail_total близко к 0\nЕсли signature failures > 0:\n- проверять partial rollout секретов\n- проверять ingress путь /webhooks/stripe\n\n# 6) Фоновые джобы\n- Kafka lag индексатора не растет неделями\n- refund-reconciler успешно отработал за 24ч\n- stripe-webhook-replay cronjob не запускается сам по себе\n\n# 7) Секреты и сертификаты\n- Stripe ключи ротируются раз в квартал\n- проверить, что после ротации все поды перезапущены (иначе интермиттентные ошибки)\n- проверить срок TLS сертификатов ingress\n\n# 8) Алерты и дашборды\n- топ шумных алертов, убрать флап\n- убедиться, что панели Grafana не ссылаются на удаленные метрики\n\n# 9) CI/CD и registry\n- нет очередей GitHub Actions\n- последний промоутнутый SHA существует в registry\n- ретеншн registry чистит старые sha теги\n\n# 10) SLO\n- недельный error budget burn для checkout-service и payment-gateway\nЕсли > 30 процентов за неделю, открыть reliability тикет даже без SEV инцидента.\n\n# Выход\nСоздать weekly ops тикет:\n- что проверили\n- что нашли\n- какие тикеты открыли\n\n# Ссылки\n- RB-2024-11, RB-2025-06, RB-2025-12, RB-2026-01, RB-2026-02\n- ADR-2024-08, ADR-2025-02, ADR-2025-03"
    },
    {
      "doc_id": "rb-2026-02-redis-evictions",
      "title": "Ранбук: Redis eviction и рассинхрон корзины/чекаута",
      "document_type": "runbook",
      "created_at": "2026-02-02",
      "content": "# Кратко\nЭтот ранбук для инцидентов, когда Redis (кластер Redis 7.2.4) начинает активно выкидывать ключи, тормозит или становится недоступен, и это приводит к странному поведению корзины и ошибкам при оформлении заказа.\n\nОсновные сервисы: cart-service, checkout-service\n\nКлючевые симптомы: всплеск 409 CART_VERSION_MISMATCH и 412 PRECONDITION_FAILED на POST /api/checkout/start, рост redis_evicted_keys_total, cache miss в cart-service выше 0.85.\n\n# Как выглядит норма\n- cart-service p95 80–140мс\n- checkout-service 409 почти 0\n- Redis: used_memory/maxmemory < 0.75, evicted_keys стабильный 0/мин\n- TTL корзины 900с (CART_CACHE_TTL_SECONDS=900), джиттер включен (CART_CACHE_TTL_JITTER_SECONDS=120)\n\n# Симптомы\n## Пользовательские\n- после обновления страницы корзина как будто теряет часть товаров\n- чекаут зацикливается с сообщением типа корзина изменилась, попробуйте снова\n- платеж висит в pending, но заказ не продвигается\n\n## Логи/ошибки\ncart-service:\n- redis.exceptions.ConnectionError: Error 111 connecting to redis.ecommerce-prod.svc:6379\n- CacheWriteSkipped size_bytes=221332 reason=value_too_large\n- cart_etag_source=redis etag_reset=true\n\ncheckout-service:\n- CartPreconditionFailed: missing If-Match\n- CART_VERSION_MISMATCH expected=18 got=17 cart_id=...\n\n# Где смотреть\nGrafana:\n- Platform / Redis / Cache Health\n- cart-service / Cache + DB\n- checkout-service / Funnel\n\nPrometheus алерты:\n- RedisEvictionsHigh: increase(redis_evicted_keys_total[5m]) > 500\n- CartVersionMismatchSpike: rate(http_responses_total{service=checkout-service,status=409}[5m]) > 5\n\n# Быстрый триаж (до 10 минут)\n1) Проверить масштаб: только корзина/чекаут или еще rate-limit, сессии, идемпотентность Stripe.\n2) Проверить Redis:\n`bash\nkubectl -n ecommerce-prod port-forward svc/redis 6379:6379\nredis-cli -p 6379 INFO memory | egrep 'used_memory_human|maxmemory_human|mem_fragmentation_ratio'\nredis-cli -p 6379 INFO stats | egrep 'evicted_keys|keyspace_hits|keyspace_misses'\nredis-cli -p 6379 CLUSTER INFO\n`\n3) Проверить размер значений корзины:\n- метрика cart_cache_value_size_bytes (p95)\n- если метрики нет, посмотреть логи на CacheWriteSkipped и size_bytes\n4) Проверить деплой за последний час: изменения сериализации корзины, рекомендаций, TTL/джиттера.\n\n# Митигирующие действия\nВыбирайте наименее рискованный вариант.\n\n## Вариант A: Временно обойти Redis для чтения корзины (предпочтительно)\nИдея: cart-service читает из Postgres, не пишет обратно в Redis.\n- CART_CACHE_BYPASS=true\n- CART_CACHE_WRITEBACK=false\n`bash\nkubectl -n ecommerce-prod set env deploy/cart-service CART_CACHE_BYPASS=true CART_CACHE_WRITEBACK=false\nkubectl -n ecommerce-prod rollout status deploy/cart-service\n`\nЦена: растет нагрузка на Postgres. Следите за numbackends и p95 checkout.\n\n## Вариант B: Снизить TTL и включить жесткий лимит размера\nЕсли Redis живой, но память упирается в maxmemory:\n- CART_CACHE_TTL_SECONDS=120\n- CART_CACHE_MAX_BYTES=131072\n`bash\nkubectl -n ecommerce-prod set env deploy/cart-service CART_CACHE_TTL_SECONDS=120 CART_CACHE_MAX_BYTES=131072\n`\nПримечание: большие корзины могут не кешироваться. Это ок, лучше чем трешинг.\n\n## Вариант C: Стабилизировать ETag\nЕсли основной ущерб от 409:\n- CART_ETAG_SOURCE=postgres (в checkout-service или общий модуль)\n- CHECKOUT_RETRY_ON_CART_MISMATCH=true (временно)\n`bash\nkubectl -n ecommerce-prod set env deploy/checkout-service CART_ETAG_SOURCE=postgres CHECKOUT_RETRY_ON_CART_MISMATCH=true\n`\n\n## Вариант D: Освободить память в Redis (последний шанс)\n1) Найти крупные ключи (осторожно, это может быть медленно):\n`bash\nredis-cli -p 6379 --scan --pattern 'cart:*' | head -n 2000 | xargs -n 50 redis-cli -p 6379 MEMORY USAGE\n`\n2) Удалить только явных монстров (корзины с раздувшимся payload):\n`bash\nredis-cli -p 6379 --scan --pattern 'cart:*' | head -n 500 | xargs -n 50 redis-cli -p 6379 DEL\n`\nРиск: кратковременный скачок нагрузки на Postgres.\n\n# Верификация и откат мер\n- redis_evicted_keys_total перестает расти\n- cache miss падает < 0.5 (после постепенного включения)\n- 409/412 возвращаются к базовому уровню\n\nПостепенно вернуть кеш:\n`bash\nkubectl -n ecommerce-prod set env deploy/cart-service CART_CACHE_BYPASS=false CART_CACHE_WRITEBACK=false\n# через 10–15 минут\nkubectl -n ecommerce-prod set env deploy/cart-service CART_CACHE_WRITEBACK=true CART_CACHE_TTL_SECONDS=900 CART_CACHE_TTL_JITTER_SECONDS=120\n`\n\n# Острые углы\n- Реплика-лаг: если чтение идет с реплик, ETag может как будто откатываться назад. Проверяйте INFO replication.\n- Смена формата ключей после деплоя: cart: vs cart2: даст 100 процентов miss без eviction.\n- Большие корзины (200+ позиций) могут превышать 256КБ. Должно быть CacheWriteSkipped.\n- Стадо при ре-гидратации: после bypass много корзин одновременно прогреваются. Без джиттера TTL будет синхронный шторм.\n\n# Ссылки\n- ADR-2025-03 Redis как кеш корзины\n- PM-2025-11 Redis eviction сломал чекаут\n- CL-2025-09 чеклист прод-деплоя (наблюдать Redis на изменениях кеша)"
    },
    {
      "doc_id": "rb-2026-01-stripe-webhook-backlog",
      "title": "Ранбук: backlog Stripe webhook и заказы в PAYMENT_PENDING",
      "document_type": "runbook",
      "created_at": "2026-01-14",
      "content": "# Кратко\nРанбук для случаев, когда Stripe webhooks начинают обрабатываться с задержкой, и заказы висят в PAYMENT_PENDING, возвраты не завершаются, или растет очередь stripe_webhook_queue_depth.\n\nГлавное: не пытайтесь чинить это срочным поллингом Stripe в горячем пути. Мы договорились, что вебхуки являются источником истины (ADR-2024-12). Поллинг допускается только как ре-консиляция.\n\nСервисы: payment-gateway (Node 18), checkout-service (FastAPI)\n\n# Симптомы\n## Пользовательские\n- Платеж подтвержден банком, но в нашем UI долго pending (больше 2 минут)\n- В Stripe Dashboard PaymentIntent succeeded, а у нас payment_status=PENDING\n- Refund requested висит без завершения\n\n## Метрики/алерты\n- stripe_webhook_queue_depth > 2000 10 минут\n- рост stripe_signature_fail_total\n- рост 5xx на POST /webhooks/stripe\n\n# Текущая схема\n1) Stripe шлет POST /webhooks/stripe на payment-gateway.\n2) payment-gateway проверяет подпись. Stripe API version закреплен 2023-10-16.\n3) Сырые события пишутся в Postgres таблицу stripe_events (PK event_id).\n4) Воркер обрабатывает события и обновляет payments/orders.\n5) checkout-service читает состояние из Postgres, не ходит в Stripe.\n\nИдемпотентность:\n- Уникальный stripe_events.event_id\n- Redis ключ stripe:evt:<event_id> TTL 7 дней (ускорение, не корректность)\n\n# Быстрый триаж\n1) В Stripe Dashboard посмотреть Delivery для endpoint webhooks/stripe.\nТиповые коды:\n- 400 invalid_signature\n- 413 payload too large\n- 429 throttling\n- 500 мы падаем до persistence\n\n2) Логи payment-gateway:\n`bash\nkubectl -n ecommerce-prod logs deploy/payment-gateway --since=15m | egrep 'invalid_signature|Signature|payload too large|OOMKilled|ETIMEDOUT|deadlock'\n`\n\n3) Проверить, что raw body не ломается.\nWebhook маршрут обязан быть на express.raw:\n`js\napp.post('/webhooks/stripe', express.raw({ type: 'application/json' }), handleStripeWebhook)\n`\nЕсли кто-то включил глобально express.json до этого маршрута, подписи начнут валиться.\n\n4) Проверить, что события вообще пишутся:\n`sql\nselect max(created_at) from stripe_events;\nselect count(*) from stripe_events where created_at > now() - interval '10 minutes';\n`\n\n# Митигирующие действия\n## A: invalid_signature (400)\nЦель: перестать отбрасывать валидные события.\n- Проверить STRIPE_WEBHOOK_SECRET актуален\n- Проверить ingress не модифицирует тело запроса\n- Если подозрение на регрессию парсинга, быстрый вариант: rollback payment-gateway на прошлый тег (например 1.38.2)\n`bash\nkubectl -n ecommerce-prod rollout undo deploy/payment-gateway\n`\n\n## B: 413 payload too large\nЧасто возникает при expand объектов (invoice lines) или неожиданно больших event payload.\n- Увеличить лимит тела на ingress для этого пути:\n`yaml\nnginx.ingress.kubernetes.io/proxy-body-size: 2m\n`\n- Проверить, что маршрут не проходит через промежуточный gateway с лимитом 1МБ.\n\n## C: Очередь растет, но ответы Stripe 2xx\nЗначит ingest ok, тормозит процессинг.\n- Увеличить WEBHOOK_MAX_CONCURRENCY умеренно (20 -> 50)\n- Отключить побочные эффекты на время: PAYMENTS_SEND_EMAILS=false\n- Перевести в режим persist+defer: WEBHOOK_DEFER_PROCESSING=true\n- Если очередь в Redis и Redis деградирует, временно: WEBHOOK_QUEUE_BACKEND=memory (не durable)\n\n## D: Postgres таймауты\nЕсли payment-gateway возвращает 500 из-за БД, Stripe будет ретраить, backlog на стороне Stripe тоже растет.\n- Уменьшить concurrency (WEBHOOK_MAX_CONCURRENCY=10)\n- Проверить connection exhaustion (см. RB-2024-11)\n- Если deadlock detected, смотреть последние миграции и индексы на stripe_events/payments\n\n# Безопасный replay\nОбычно Stripe ретраи достаточно. Ручной replay нужен только если мы когда-то вернули 2xx без записи в БД (это баг).\nЗапуск джобы:\n`bash\nkubectl -n ecommerce-prod create job --from=cronjob/stripe-webhook-replay stripe-webhook-replay-manual\n`\nПравила:\n- idempotent по event_id\n- терпит out-of-order типы\n\n# Проверка восстановления\n- В Stripe Dashboard последние доставки 2xx\n- stripe_webhook_queue_depth падает\n- В payments за последние 30 минут доля PENDING не растет\n\nSQL:\n`sql\nselect payment_status, count(*) from payments where created_at > now() - interval '30 minutes' group by 1;\nselect type, count(*) from stripe_events where created_at > now() - interval '30 minutes' group by 1 order by 2 desc;\n`\n\n# Edge cases\n- Out-of-order: refund события могут прийти до succeeded при ретраях\n- Дубликаты: Stripe может прислать один event_id несколько раз. Нельзя убирать уникальность, это сломает корректность.\n- Partial rollout секрета: часть подов принимает, часть отклоняет, будет каша из 2xx и 400.\n- Дрейф часов: подпись может падать по tolerance. Если только один узел ломается, проверьте NTP.\n\n# Ссылки\n- ADR-2024-12 вебхуки как источник истины\n- OB-2025-04 онбординг по платежам\n- PM-2025-08 дубликаты отгрузки при ретраях"
    },
    {
      "doc_id": "rb-2025-12-es-cluster-red",
      "title": "Ранбук: Elasticsearch red/yellow и деградация поиска",
      "document_type": "runbook",
      "created_at": "2025-12-03",
      "content": "# Кратко\nРанбук для ситуаций, когда Elasticsearch кластер становится yellow/red, появляются unassigned shards, растут 429 es_rejected_execution_exception, или индексирование отстает, и search-api начинает отдавать 503 SEARCH_UNAVAILABLE.\n\nСервисы: search-api, indexing-worker\n\nСтек: Elasticsearch 8.11.3 (3 master-eligible + 6 data nodes), индексы products-v3-*, алиас products_read (ADR-2025-02)\n\n# Норма\n- Cluster health green\n- search-api p95 120–220мс\n- Threadpool search/write очереди близко к 0\n- Kafka lag по catalog.product.changed < 50к и быстро догоняет\n- Диски data-node < 70 процентов\n\n# Симптомы\nsearch-api:\n- ConnectionTimeout\n- 429 es_rejected_execution_exception\n- index_not_found_exception: no such index [products_read]\n\nindexing-worker:\n- BulkIndexError: N documents failed\n- mapper_parsing_exception по attributes.*\n\n# Где смотреть\nGrafana:\n- Search / search-api\n- Platform / Elasticsearch / Cluster\n- Indexing / Kafka Lag\n\nАлерты:\n- ElasticsearchClusterRed\n- ElasticsearchDiskHighWatermark\n- SearchApi503Spike\n\n# Быстрый триаж\n1) Health:\n`bash\nkubectl -n ecommerce-prod port-forward svc/elasticsearch 9200:9200\ncurl -s http://localhost:9200/_cluster/health?pretty\n`\n2) Allocation explain:\n`bash\ncurl -s http://localhost:9200/_cluster/allocation/explain?pretty\n`\n3) Проверить алиас:\n`bash\ncurl -s http://localhost:9200/_cat/aliases/products_read?v\n`\n4) Threadpool:\n`bash\ncurl -s http://localhost:9200/_cat/thread_pool/search?v\ncurl -s http://localhost:9200/_cat/thread_pool/write?v\n`\n\n# Митигирующие действия\n## A: Disk watermark и unassigned shards\nЕсли причина disk_threshold:\n- Посмотреть старые индексы:\n`bash\ncurl -s 'http://localhost:9200/_cat/indices/products-v3-*?h=index,store.size,docs.count&s=index'\n`\n- Удалить явно устаревшие (ретеншн 14 дней). Важно: не удалить индекс, на который указывает products_read.\n`bash\ncurl -s 'http://localhost:9200/_cat/aliases/products_read?h=index'\ncurl -s -X DELETE 'http://localhost:9200/products-v3-2025.0*'\n`\nЕсли ILM сломан и не чистит, ручное удаление допустимо во время инцидента, но потом нужно восстановить ILM.\n\n## B: 429 и перегруз\nВключить деградацию в search-api:\n- SEARCH_ENABLE_AGGS=false\n- SEARCH_ENABLE_SPELLCHECK=false\n- SEARCH_MAX_CONCURRENCY=40 (вместо 80)\n`bash\nkubectl -n ecommerce-prod set env deploy/search-api SEARCH_ENABLE_AGGS=false SEARCH_ENABLE_SPELLCHECK=false SEARCH_MAX_CONCURRENCY=40\n`\nПараллельно уменьшить давление от индексатора.\n\n## C: Индексатор разогнал write\nЕсли lag огромный и write queue растет:\n- Пауза indexing-worker:\n`bash\nkubectl -n ecommerce-prod scale deploy/indexing-worker --replicas=0\n`\n- После стабилизации вернуть 1 реплику и меньший bulk:\n  - INDEXING_BULK_SIZE=250 (вместо 1000)\n  - INDEXING_FLUSH_INTERVAL_MS=750 (вместо 250)\n\n## D: Несовместимость mapping после деплоя\nЕсли search-api стал запрашивать поле, которого нет, или тип поменялся:\n- Быстро откатить search-api на совместимую версию\n- Либо временно вернуть products_read на старый индекс (атомарный switch алиаса):\n`bash\ncurl -s -X POST http://localhost:9200/_aliases -H 'Content-Type: application/json' -d '{\n  \"actions\": [\n    {\"remove\": {\"alias\": \"products_read\", \"index\": \"products-v3-2025.02.06\"}},\n    {\"add\": {\"alias\": \"products_read\", \"index\": \"products-v3-2025.01.30\"}}\n  ]\n}'\n`\nЕсли мешают двойные кавычки в примере, можно выполнить тот же запрос из файла.\n\n# Восстановление\n- Health green 10+ минут\n- search-api p95 < 250мс\n- Kafka lag по индексации начинает падать\n\nВозвращать indexing-worker постепенно: 1 реплика, маленький bulk, затем scale.\n\n# Острые углы\n- Hot shard: кластер зеленый, но один shard перегружен (популярная категория). Смотреть _cat/shards.\n- Master instability: master_not_discovered_exception. Не делайте ручной allocation до стабилизации мастеров.\n- Merge storm: слишком агрессивная индексация вызывает CPU spikes и замедляет поиск.\n- Type conflicts: attributes.size как строка в одних товарах и число в других приведет к mapper_parsing_exception.\n\n# Ссылки\n- ADR-2025-02 стратегия алиасов\n- API search-api v3\n- CL-2025-10 еженедельный ops чеклист (ILM/ретеншн)"
    },
    {
      "doc_id": "rb-2025-06-k8s-rollout-stuck",
      "title": "Ранбук: Rollout завис, CrashLoopBackOff, readiness не проходит",
      "document_type": "runbook",
      "created_at": "2025-06-21",
      "content": "# Кратко\nРанбук для случаев, когда деплой в Kubernetes зависает, новые поды в CrashLoopBackOff, или readiness probe не проходит и ingress начинает отдавать 502/503.\n\nКластеры: Kubernetes 1.29, namespaces ecommerce-prod / ecommerce-staging\nСервисы: checkout-service, cart-service, search-api (FastAPI 0.110), payment-gateway (Node 18)\n\n# Типовые симптомы\n- kubectl rollout status висит > 5 минут\n- Поды: CrashLoopBackOff, ImagePullBackOff, OOMKilled, Readiness probe failed\n- Пользовательские: всплеск 5xx после деплоя, частичные ошибки (mixed versions)\n\n# Быстрый триаж\n1) Статус rollout:\n`bash\nkubectl -n ecommerce-prod rollout status deploy/checkout-service\nkubectl -n ecommerce-prod get pods -l app=checkout-service -o wide\n`\n2) Describe проблемного пода:\n`bash\nkubectl -n ecommerce-prod describe pod <pod>\n`\nСмотреть Events: pull errors, probe failures, OOM.\n\n3) Логи текущие и предыдущие:\n`bash\nkubectl -n ecommerce-prod logs <pod> --previous --tail=200\nkubectl -n ecommerce-prod logs <pod> --tail=200\n`\n\n# Митигирующие сценарии\n## A: Readiness probe падает\nПроверить локально внутри пода:\n`bash\nkubectl -n ecommerce-prod exec -it <pod> -- sh -c 'wget -qO- http://127.0.0.1:8080/health/ready || true'\n`\nЕсли readiness включает внешние зависимости, решите, должна ли она быть строгой.\nМы поддерживаем READINESS_STRICT_DEPS=false для сервисов с fallback (например cart-service может жить на Postgres без Redis).\n\nВременный фикс для cart-service:\n`bash\nkubectl -n ecommerce-prod set env deploy/cart-service READINESS_STRICT_DEPS=false\n`\nВнимание: если readiness становится слишком мягкой, вы можете начать принимать трафик в деградированном состоянии. Это нормально только как временная мера.\n\n## B: CrashLoop из-за отсутствующего env/secret\nFastAPI валидирует settings и падает быстро.\nТиповые сообщения:\n- ValidationError: Settings.STRIPE_API_KEY Field required\n- KeyError по переменной\n\nДействия:\n- проверить секрет существует\n- сравнить имена ключей в Deployment и в коде\n- если не уверены, откатить (быстрее, чем патчить на горячую)\n`bash\nkubectl -n ecommerce-prod rollout undo deploy/checkout-service\n`\n\n## C: Schema drift (миграции не применились)\nСимптом: psycopg.errors.UndefinedColumn.\nДействия:\n1) Откатить сервис.\n2) Запустить миграцию джобой против primary Postgres (не через PgBouncer):\n`bash\nkubectl -n ecommerce-prod create job --from=cronjob/checkout-migrations checkout-migrations-manual\n`\n3) После применения снова деплоить.\n\n## D: OOMKilled\nСимптом: Last State Terminated OOMKilled.\nДействия:\n- временно увеличить memory limit и посмотреть, стабилизируется ли\n- если это регрессия (логирование больших payload, кеширование в памяти), откатить и чинить в ветке\n\n## E: ImagePullBackOff\nПричины:\n- тег не собран (ошибка GitHub Actions)\n- промоут ссылается на несуществующий SHA\n- сломан imagePullSecret\n\nФикс: быстро указать прошлый известный рабочий образ или откатить rollout.\n\n# Опасность частичного rollout (mixed versions)\nДаже если readiness проходит, смешанные версии могут ломать инварианты:\n- изменение формата Redis ключей cart: vs cart2:\n- checkout-service ожидает новые error_code от cart-service\n\nЕсли подозрение на несовместимость, выбирайте rollback, а не ожидание.\n\n# Проверка после мер\n- rollout завершился\n- ingress 5xx вернулся к базовому\n- по сервису нет новых ValidationError/UndefinedColumn\n\nСмоук:\n`bash\ncurl -sSf https://api.company.tld/healthz >/dev/null\ncurl -sSf https://api.company.tld/api/search/products?q=sneakers | head -n 5\n`\n\n# После инцидента\n- Добавить pre-deploy проверки: секреты, alembic head, наличие алиаса products_read\n- Пересмотреть readiness: liveness не должен ходить во внешние системы\n- Если причина связана с миграциями, связать с PM-2025-07"
    },
    {
      "doc_id": "rb-2024-11-postgres-conn-exhaustion",
      "title": "Ранбук: исчерпание подключений Postgres (too many clients)",
      "document_type": "runbook",
      "created_at": "2024-11-09",
      "content": "# Кратко\nРанбук для случаев, когда Postgres начинает отказывать в новых подключениях, или latency взлетает из-за очередей в пулах. Типовая ошибка: FATAL sorry, too many clients already.\n\nПричина чаще всего: сервисы обходят PgBouncer или увеличили pool/worker в деплое. Мы используем PgBouncer transaction pooling (ADR-2024-08).\n\n# Симптомы\n- Массовые 500 на checkout-service/cart-service/payment-gateway\n- Таймауты, зависания запросов\n\nЛоги FastAPI:\n- psycopg.OperationalError: FATAL sorry, too many clients already\n- sqlalchemy.exc.TimeoutError: QueuePool limit reached\n\nЛоги Node (pg):\n- remaining connection slots are reserved...\n\n# Архитектура\n- Primary Postgres (приложениям нельзя): postgres-primary.ecommerce-prod.svc:5432\n- PgBouncer (приложениям нужно): pgbouncer.ecommerce-prod.svc:6432\n- Миграции Alembic должны ходить в primary напрямую\n\n# Быстрый триаж\n1) Посчитать коннекты и топ-источники:\n`sql\nshow max_connections;\nselect count(*) as total from pg_stat_activity;\nselect application_name, usename, state, count(*)\nfrom pg_stat_activity\ngroup by 1,2,3\norder by count(*) desc\nlimit 15;\n`\nЕсли application_name пустой или дефолтный, это подозрение на неправильную строку подключения.\n\n2) Проверить idle in transaction:\n`sql\nselect pid, application_name, now() - xact_start as xact_age, query\nfrom pg_stat_activity\nwhere state = 'idle in transaction'\norder by xact_age desc\nlimit 20;\n`\n\n3) PgBouncer:\nЕсли доступен admin:\n`sql\nshow pools;\nshow stats;\n`\nСмотрите cl_waiting.\n\n# Митигирующие действия\n## A: Снизить параллелизм приложений (самое безопасное)\nДля FastAPI число воркеров умножает пул.\n- WEB_CONCURRENCY=2\n- DB_POOL_SIZE=10\n- DB_MAX_OVERFLOW=5\n\n`bash\nkubectl -n ecommerce-prod set env deploy/checkout-service WEB_CONCURRENCY=2 DB_POOL_SIZE=10 DB_MAX_OVERFLOW=5\nkubectl -n ecommerce-prod set env deploy/cart-service WEB_CONCURRENCY=2 DB_POOL_SIZE=10 DB_MAX_OVERFLOW=5\n`\nПодождать 2–3 минуты, проверить pg_stat_activity.\n\n## B: Вернуть сервисы на PgBouncer\nЕсли деплой поменял DATABASE_URL на primary:\n- Патчить env обратно на pgbouncer и перезапустить pods\n- Или откатить rollout\n\nЭто самый частый root cause резких всплесков.\n\n## C: Убить явно зависшие сессии (последний шанс)\nТолько если уверены, что это мусор (например тысячи idle in transaction от одного пода):\n`sql\nselect pg_terminate_backend(pid)\nfrom pg_stat_activity\nwhere application_name like 'checkout-service@%' and state='idle in transaction'\n  and now() - xact_start > interval '2 minutes';\n`\nРиск: упадут запросы, возможны частичные операции.\n\n## D: Включить rate limit для защиты БД\nЕсли система близка к коллапсу:\n- лимитировать /api/checkout/start и /api/cart/* на ingress\n- лучше 429 чем каскад 500\n- временно остановить indexing-worker\n\n# Восстановление\nНормально:\n- total connections < 70 процентов от max\n- PgBouncer cl_waiting близко к 0\n- p95 возвращается\n\n# Острые углы\n- Лики соединений: забыли закрывать session на исключениях\n- Неправильное использование sync и async engine (двойные пулы)\n- Prepared statements и session state ломаются в transaction pooling\n- Джобы (refund-reconciler, webhook workers) тоже потребляют коннекты, учитывайте их в анализе\n\n# Ссылки\n- ADR-2024-08 PgBouncer\n- RB-2025-06 rollout stuck (часто рядом)\n- PM-2025-07 про миграции через PgBouncer"
    },
    {
      "doc_id": "adr-2024-12-stripe-webhooks",
      "title": "ADR-2024-12: Stripe webhooks как источник истины по платежам",
      "document_type": "adr",
      "created_at": "2024-12-15",
      "content": "# Статус\nПринято (2024-12-15)\n\n# Контекст\nРаньше checkout-service делал активный поллинг Stripe (retrieve PaymentIntent) чтобы понять финальный статус. Это приводило к:\n- 429 Too Many Requests на пиках\n- гонкам: заказ pending при фактически успешном платеже\n- сложным retry/backoff в горячем пути и росту p95\n- слабой аудитируемости: поддержки нет каноничного журнала событий\n\nУ нас есть legacy Node сервис payment-gateway, который уже принимает Stripe webhooks, но его выход не считался авторитетным. По сути было два конкурирующих источника правды.\n\n# Решение\nСделать Stripe webhooks авторитетным источником переходов платежного статуса.\n- payment-gateway:\n  1) проверяет подпись\n  2) сохраняет сырое событие в Postgres\n  3) ставит в очередь внутреннюю обработку\n- checkout-service:\n  - не поллит Stripe в запросах пользователя\n  - обновляет payments и orders только по результатам обработанных webhook событий\n\nПоллинг допускается только как оффлайновая ре-консиляция (например ежедневная) и для ручного инструмента поддержки.\n\n# Дизайн\n## Версия Stripe API\nФиксируем версию на 2023-10-16 в payment-gateway и логируем ее как stripe_api_version.\n\n## Endpoint\n- POST /webhooks/stripe\n- Требование: тело запроса должно быть raw, без переформатирования JSON.\n- В payment-gateway для этого маршрута использовать express.raw.\n\n## Проверка подписи\n- env: STRIPE_WEBHOOK_SECRET\n- При неверной подписи отвечаем 400.\nТиповой лог: StripeSignatureVerificationError.\n\n## Persistence\nТаблица stripe_events хранит payload целиком (jsonb) для аудита и replay.\n\nСхема:\n`sql\ncreate table stripe_events (\n  event_id text primary key,\n  type text not null,\n  created_at timestamptz not null default now(),\n  payload jsonb not null,\n  processed_at timestamptz,\n  process_error text\n);\ncreate index stripe_events_type_created_at_idx on stripe_events (type, created_at desc);\n`\n\n## Процессинг\n- Воркер берет event_id, читает payload, применяет переходы в транзакции.\n- Идемпотентность: PK event_id и уникальность на связях с payments.\n\n## Порядок событий\nStripe не гарантирует порядок. Процессор обязан терпеть:\n- дубликаты\n- out-of-order, включая refund события до succeeded\n\nПравило: переходы по возможности монотонные, не откатывать платеж из SUCCEEDED в PENDING.\n\n## Поведение при сбоях\nЕсли payment-gateway не может записать событие в Postgres, должен вернуть 500, чтобы Stripe ретраил. Нельзя отдавать 2xx без записи.\n\n# Последствия\nПлюсы:\n- меньше Stripe API вызовов и меньше 429\n- единый журнал событий\n- ясное разделение ответственности\n\nМинусы/риски:\n- webhook ingestion становится критичным для финализации заказа\n- регрессия в raw-body обработке сразу приводит к зависшим pending\n- нужны алерты на очередь и подписи (см. RB-2026-01)\n\n# Альтернативы\n- оставить поллинг: отклонено\n- перенести вебхуки в checkout-service: отклонено из-за владения ключами\n- публиковать события в Kafka: отложено\n\n# Заметки\n- ingress лимит тела должен быть достаточным, иначе 413.\n- Redis используется как ускорение, но корректность держится на Postgres.\n- В PM-2025-08 выяснилось, что downstream consumers должны быть идемпотентны даже если ingestion идемпотентен."
    },
    {
      "doc_id": "adr-2025-03-redis-carts",
      "title": "ADR-2025-03: Redis как основной кеш для корзин (read-through + write-through)",
      "document_type": "adr",
      "created_at": "2025-03-11",
      "content": "# Статус\nПринято (2025-03-11)\n\n# Контекст\ncart-service — высоконагруженный сервис. На пиках чтение корзины становится одним из топ источников нагрузки на Postgres, что ухудшает чекаут. In-process кеш на подах пробовали, но:\n- прогрев разный на каждом поде\n- деплой сбрасывает кеш и вызывает шторм\n- память растет непредсказуемо\n\nRedis уже используется для сессий, rate-limit и идемпотентности платежей, поэтому логично применить его как общий кеш.\n\n# Решение\nИспользовать Redis как основной кеш для payload корзины, при этом Postgres остается источником истины.\n- read-through на GET\n- write-through на мутациях\n- TTL + джиттер\n- policy: allkeys-lfu\n\nЭто НЕ означает, что Redis становится системой записи.\n\n# Дизайн\n## Формат ключей\nКлюч должен быть стабильным:\n- cart:<user_id>:v<version>\n\n## TTL\n- CART_CACHE_TTL_SECONDS=900\n- CART_CACHE_TTL_JITTER_SECONDS=120\n\n## Сериализация\n- msgpack v2 (быстрее и меньше чем JSON)\n- payload включает cart_id, version, currency, items, минимальные totals\nИсключить:\n- расширенные рекомендации\n- профиль пользователя\n\n## Redis конфиг (prod baseline)\n`conf\nmaxmemory 18gb\nmaxmemory-policy allkeys-lfu\nactivedefrag yes\nlazyfree-lazy-eviction yes\n`\n\n## Поведение cart-service\nGET:\n- при hit возвращаем X-Cache: hit\n- при miss читаем из Postgres и пишем в Redis\n- при недоступном Redis: fallback на Postgres, X-Cache: bypass\n\nМутации:\n- транзакция в Postgres\n- инкремент version\n- запись нового payload в Redis\n- публикация cart.updated (для аналитики, не критично)\n\n## ETag и optimistic concurrency\ncart-service возвращает ETag, checkout-service передает If-Match.\nОжидание: 409 при несовпадении, клиент должен перезагрузить корзину.\n\nРиск: если ETag вычисляется из кешированного payload, eviction/rehydrate может повысить mismatch. Это позже подтвердилось в PM-2025-11.\n\n# Последствия\nПлюсы:\n- меньше Postgres read load\n- ниже latency\n\nМинусы:\n- Redis становится большим радиусом поражения: eviction шторм возвращает нагрузку в БД\n- риск раздувания payload\n- риск partial deploy при смене формата ключей\n\n# Альтернативы\n- Postgres-only с репликами: дороже и p95 хуже\n- Хранить корзины в Redis как источник истины: отклонено\n- Клиентский кеш: отклонено\n\n# Требования и follow-ups\n- добавить алерты на redis_evicted_keys_total и размер payload\n- добавить жесткий лимит CART_CACHE_MAX_BYTES и пропуск кеширования больших payload\n- ранбук на инциденты (RB-2026-02)\n\n# Примечание о противоречиях\nЭта ADR про производительность. Если Redis будет причиной повторяющихся инцидентов, возможен пересмотр: кешировать только минимальный набор (sku+qty) или вовсе уйти в Postgres+реплики. Это пока не принято, но обсуждалось после PM-2025-11."
    },
    {
      "doc_id": "adr-2025-02-es-aliasing",
      "title": "ADR-2025-02: Алиасы Elasticsearch и reindex без простоя",
      "document_type": "adr",
      "created_at": "2025-02-06",
      "content": "# Статус\nПринято (2025-02-06)\n\n# Контекст\nМаппинги Elasticsearch часто нужно менять (анализаторы, новые поля, типы). In-place изменения ограничены. Полный reindex каталога занимает часы. Раньше у нас был один индекс products-current, что делало деплои рискованными и плохо откатываемыми.\n\nНужно:\n- атомарный cutover\n- быстрый rollback\n- независимые релизы search-api и indexing-worker\n\n# Решение\nВводим read/write алиасы:\n- products_read\n- products_write\n\nКонкретные индексы: products-v3-YYYY.MM.DD\nindexing-worker пишет в products_write, search-api читает products_read. Во время миграций алиасы могут указывать на разные индексы.\n\n# Дизайн\n## Шаблон и ограничения\nTemplate: products-template-v3\nПравила:\n- attributes.* нормализовать, избегать field explosion\n- index.mapping.total_fields.limit=1000\n\nПример settings:\n`json\n{\n  \"number_of_shards\": 12,\n  \"number_of_replicas\": 1,\n  \"index.mapping.total_fields.limit\": 1000\n}\n`\n\n## Процесс cutover\n1) Создать новый индекс products-v3-<today>.\n2) Backfill:\n- предпочтительно из Postgres снапшота\n- запасной вариант: _reindex со старого\n3) Включить dual-write:\n- INDEX_DUAL_WRITE=true\n- INDEX_DUAL_WRITE_TARGET=products-v3-<today>\n4) Переключить products_read на новый индекс.\n5) Проверить query parity и doc counts.\n6) Переключить products_write и выключить dual-write.\n\n## Валидация\n- doc count в пределах 0.5 процента\n- 20 каноничных запросов дают близкие totals (+/- 5%)\n- нет query_shard_exception в логах\n\n## Rollback\nRollback = вернуть products_read на старый индекс. Это ключевой плюс.\n\n# Последствия\nПлюсы:\n- reindex без простоя\n- быстрый rollback\n\nМинусы:\n- доп storage во время dual-write\n- operational complexity: алиасы, ILM и ретеншн должны быть корректны\n- новый failure mode: products_read отсутствует или указывает на удаленный индекс => search-api падает index_not_found_exception (см. RB-2025-12)\n\n# Edge cases\n- Disk watermark: unassigned shards, алиасы не помогут\n- Type conflicts: смена типа поля приводит к mapper_parsing_exception\n- Analyzer changes: релевантность меняется, нужен sign-off продукта\n\n# Follow-ups\n- ILM должен покрывать products-v3-*.\n- Еженедельный чеклист проверяет алиасы и ретеншн.\n\n# Примечание\nВ 2025-12 был инцидент с red кластером из-за дисков. В контексте этой ADR важно: алиасы решают проблему миграций, но не решают проблему capacity и ретеншна."
    },
    {
      "doc_id": "adr-2024-08-pgbouncer",
      "title": "ADR-2024-08: PgBouncer в режиме transaction pooling для Postgres",
      "document_type": "adr",
      "created_at": "2024-08-22",
      "content": "# Статус\nПринято (2024-08-22)\n\n# Контекст\nСуммарное число подключений к Postgres стало неконтролируемым: web pods * workers * pool size + фоновые воркеры. На пиках это приводило к:\n- FATAL too many clients\n- каскадным таймаутам\n- деградации p95 из-за churn\n\nУвеличивать max_connections — не решение: растет память на backend и падает производительность.\n\n# Решение\nВводим PgBouncer в режиме transaction pooling для всего app трафика.\n- Приложения по умолчанию подключаются к PgBouncer (порт 6432)\n- Прямые подключения к primary Postgres (5432) только для миграций и админских задач\n\n# Дизайн\n## Базовые настройки PgBouncer (prod)\n`ini\npool_mode = transaction\nmax_client_conn = 5000\ndefault_pool_size = 50\nreserve_pool_size = 10\nserver_idle_timeout = 60\nquery_wait_timeout = 120\nignore_startup_parameters = extra_float_digits\n`\n\n## Конфиг сервисов\nFastAPI (SQLAlchemy 2.0 + psycopg):\n- DATABASE_URL на PgBouncer\n- маленький client pool чтобы не делать pool-on-pool:\n  - DB_POOL_SIZE=10\n  - DB_MAX_OVERFLOW=5\n\nNode payment-gateway (pg):\n- max=20\n- таймауты задавать на транзакцию, не через session state\n\n## Ограничения совместимости\nTransaction pooling ломает:\n- session-scoped prepared statements\n- temp tables между запросами\n- SET ROLE/SET search_path без повторного применения\n\nПолитика: если сервис требует session semantics, он должен обосновать исключение.\n\n## Мониторинг\n- PgBouncer cl_waiting, sv_active\n- Postgres numbackends\n- ошибки timeout waiting for server connection\n\n# Последствия\nПлюсы:\n- резкое снижение numbackends\n- стабильность p95\n\nМинусы:\n- PgBouncer становится критическим компонентом\n- возможны неожиданные баги библиотек\n- миграции должны идти мимо PgBouncer\n\n# План внедрения\n- staging на одном сервисе\n- миграция по одному сервису\n- в чеклист деплоя добавить проверку DATABASE_URL\n\n# Edge cases\n- PgBouncer saturation: latency растет даже при здоровом Postgres\n- деплой, случайно указывающий на primary, быстро выжигает max_connections\n- миграции через PgBouncer могут вести себя странно (это случилось в PM-2025-07)\n\n# Связанные документы\n- RB-2024-11 исчерпание подключений\n- PM-2025-07 миграции и schema drift\n- CL-2025-09 прод-деплой"
    },
    {
      "doc_id": "ob-2025-05-fastapi-local",
      "title": "Онбординг: локальная разработка FastAPI сервисов",
      "document_type": "onboarding",
      "created_at": "2025-05-05",
      "content": "# Цель\nПоднять локально checkout-service, cart-service, search-api с зависимостями (Postgres, Redis, Elasticsearch) и уметь прогонять тесты. Документ специально содержит неприятные детали: порты, переменные окружения, миграции, сиды.\n\n# Что у нас есть\n- checkout-service: FastAPI 0.110, Python 3.11, SQLAlchemy 2.0, psycopg\n- cart-service: FastAPI 0.110, Redis кеш\n- search-api: FastAPI 0.110, ES client 8.x\n- payment-gateway (Node 18) в этом гайде почти не трогаем\n\n# Пререквизиты\n- Docker Desktop 4.27+\n- Python 3.11.7\n- Poetry 1.8+\n\n# Запуск зависимостей\nИз папки infra:\n`bash\ndocker compose up -d postgres redis elasticsearch\ndocker compose ps\n`\nЭндпойнты:\n- Postgres localhost:5432 db ecommerce user app pass app\n- Redis localhost:6379 db 0\n- Elasticsearch http://localhost:9200 (без auth)\n\nЕсли конфликт портов, проще всего поменять ports в docker-compose и поправить env.\n\n# База и миграции\nКаждый сервис владеет своими миграциями. Обычно сначала гоняют checkout-service, потому что он создает таблицы orders/payments.\n\n`bash\ncd checkout-service\npoetry install\nexport DATABASE_URL=postgresql+psycopg://app:app@localhost:5432/ecommerce\npoetry run alembic upgrade head\n`\n\nТиповые проблемы:\n- Cant locate revision: репо не обновлено или DB сломана. Проще пересоздать локальную БД.\n- InsufficientPrivilege: используете не того юзера.\n\n# Запуск checkout-service\n`bash\ncd checkout-service\nexport DATABASE_URL=postgresql+psycopg://app:app@localhost:5432/ecommerce\nexport REDIS_URL=redis://localhost:6379/0\nexport PAYMENT_GATEWAY_URL=http://localhost:8090\nexport SERVICE_ENV=local\nexport STRIPE_API_KEY=sk_test_dummy\npoetry run uvicorn app.main:app --reload --port 8081\n`\nHealth:\n- GET /health/live\n- GET /health/ready\n\nВажно: STRIPE_API_KEY нужен только чтобы пройти валидацию settings, checkout-service не должен напрямую дергать Stripe.\n\n# Запуск cart-service\n`bash\ncd cart-service\npoetry install\nexport DATABASE_URL=postgresql+psycopg://app:app@localhost:5432/ecommerce\nexport REDIS_URL=redis://localhost:6379/0\nexport CART_CACHE_TTL_SECONDS=900\nexport READINESS_STRICT_DEPS=false\npoetry run uvicorn app.main:app --reload --port 8082\n`\nREADINESS_STRICT_DEPS=false локально рекомендован, потому что Redis часто рестартится.\n\n# Запуск search-api\n`bash\ncd search-api\npoetry install\nexport ELASTICSEARCH_URL=http://localhost:9200\nexport SERVICE_ENV=local\nexport SEARCH_INDEX_NAME=products-v3-local\npoetry run uvicorn app.main:app --reload --port 8083\n`\n\nИнициализация локального индекса:\n`bash\npython scripts/create_index.py --index products-v3-local\npython scripts/seed_products.py --count 500\n`\nЕсли видите index_not_found_exception по products_read, это потому что в проде используется алиас. Локально используйте SEARCH_INDEX_NAME или создайте алиас вручную.\n\n# Тесты\n`bash\npoetry run pytest -q\npytest -q -m integration\n`\nИнтеграционные тесты ждут Postgres/Redis/ES. Если зависают, проверьте что docker compose поднят.\n\n# Конвенции дебага\n- X-Request-Id прокидываем между сервисами\n- Ошибки в формате:\n  - error_code\n  - message\n  - request_id\n\n# Частые грабли\n- Poetry подхватил Python 3.12 и сломал pin зависимостей\n- ES mapping drift: проще снести локальный индекс и пересоздать\n- Порты: локально 8081/8082/8083, в контейнере 8080\n\n# Что читать дальше\n- API: cart-service v1, checkout-service v2, search-api v3\n- Ранбуки: Redis eviction, Stripe webhook backlog, ES red\n- Чеклист прод-деплоя"
    },
    {
      "doc_id": "ob-2025-04-payments",
      "title": "Онбординг: платежи и интеграция со Stripe (checkout-service + payment-gateway)",
      "document_type": "onboarding",
      "created_at": "2025-04-02",
      "content": "# Зачем этот документ\nПлатежи у нас распределены по двум сервисам:\n- checkout-service (FastAPI) оркестрирует заказ и инициирует платеж\n- payment-gateway (Node 18) владеет Stripe ключами и принимает вебхуки\n\nОсновные баги рождаются на стыках: идемпотентность, ретраи, переходы статусов.\n\n# Компоненты\n- checkout-service: создает orders/payments в Postgres\n- payment-gateway: создает PaymentIntent в Stripe, принимает webhooks\n- Postgres: таблицы orders, payments, stripe_events\n- Redis: ускорение идемпотентности и локи\n\n# Happy path\n1) Клиент вызывает POST /api/checkout/start с Idempotency-Key.\n2) checkout-service валидирует снапшот корзины через cart-service (If-Match).\n3) checkout-service пишет заказ (PAYMENT_PENDING) и платеж (PENDING).\n4) checkout-service вызывает payment-gateway internal API, тот создает PaymentIntent и возвращает client_secret.\n5) Клиент подтверждает карту.\n6) Stripe шлет webhooks.\n7) payment-gateway пишет stripe_events и обрабатывает.\n8) payment_status становится SUCCEEDED, checkout-service переводит order в PAID.\n\n# Инварианты\n## Idempotency обязательна\n- Для /api/checkout/start требуем Idempotency-Key.\n- payment-gateway должен возвращать тот же PaymentIntent при повторе того же ключа.\nЕсли клиент повторит запрос с новым ключом, можно получить дубль PaymentIntent (support боль).\n\n## Webhooks источник истины\nADR-2024-12: не поллим Stripe в горячем пути. Если вебхуки задержались, заказ может зависнуть в pending — это ожидаемо, чинить нужно ingestion.\n\n## Raw body\nПодпись Stripe проверяется по raw body. Если включить JSON parsing до проверки, будет invalid_signature.\n\n# Локальный запуск payment-gateway\n`bash\ncd payment-gateway\nnpm ci\nexport STRIPE_API_KEY=sk_test_...\nexport STRIPE_WEBHOOK_SECRET=whsec_...\nexport DATABASE_URL=postgres://app:app@localhost:5432/ecommerce\nexport REDIS_URL=redis://localhost:6379/0\nnpm run dev\n`\nПорт 8090.\n\n# Stripe CLI для локальных вебхуков\n`bash\nstripe listen --forward-to localhost:8090/webhooks/stripe\n`\nStripe CLI выдаст whsec, его надо положить в STRIPE_WEBHOOK_SECRET.\n\n# Диагностика типовых проблем\n## Stripe показывает succeeded, а у нас pending\n`sql\nselect max(created_at) from stripe_events;\nselect payment_status, provider_payment_id from payments where order_id = '<id>';\n`\nЕсли события приходят, но не обработались, смотрите stripe_events.process_error.\n\n## Дубли отгрузки\nСмотреть PM-2025-08. Даже если Stripe ingest идемпотентен, downstream consumers обязаны быть идемпотентными.\n\n## Refund застрял\nВозвраты асинхронные. Помимо вебхуков есть refund-reconciler (ежедневно). Если вебхук был пропущен, reconciler может догнать.\n\n# Edge cases\n- 3DS: PaymentIntent может быть requires_action долго, это не failure\n- Amount: все суммы в minor units\n- Валюты: поддерживаем USD и EUR. В тесте Stripe пропускает больше, но прод должен отклонять\n- Out-of-order webhooks: возможны при ретраях\n\n# Полезные документы\n- ADR-2024-12\n- RB-2026-01\n- API checkout-service v2\n- PM-2025-08 (идемпотентность внутренних событий)"
    },
    {
      "doc_id": "ob-2025-10-cicd-k8s",
      "title": "Онбординг: CI/CD и Kubernetes конвенции (GitHub Actions + Docker + K8s)",
      "document_type": "onboarding",
      "created_at": "2025-10-12",
      "content": "# Обзор\nДокумент про то, как изменения попадают в прод и как дебажить проблемы CI/деплоя. Это не учебник по K8s, а наши конкретные правила.\n\n# Окружения\n- staging: namespace ecommerce-staging, host staging-api.company.tld\n- prod: namespace ecommerce-prod, host api.company.tld\n\n# Образы\nКонвенция:\n- <service>:<git-sha>\n- <service>:v<semver>\nЗапрещено деплоить latest.\n\nПример: checkout-service:9f2c1a3, checkout-service:v2.14.0\n\n# GitHub Actions\nКаждый сервис:\n- ci.yml (PR)\n- release.yml (теги)\nПлатформа:\n- promote.yml (промоут в прод)\n\nТиповые шаги:\n- lint (ruff 0.4.x)\n- pytest\n- docker buildx\n- push в registry\n\n# Процесс деплоя\n1) merge в main -> auto deploy в staging\n2) smoke тесты\n3) запуск promote.yml с SHA\n4) мониторинг rollout + метрики 15 минут\n\n# K8s конвенции\n- liveness: /health/live (без внешних зависимостей)\n- readiness: /health/ready (может проверять БД, но осторожно)\n\nПорты:\n- FastAPI 8080 в контейнере\n- payment-gateway 8090\n\n# Дебаг деплоя\nБыстрый набор команд:\n`bash\nkubectl -n ecommerce-prod rollout status deploy/cart-service\nkubectl -n ecommerce-prod get pods -l app=cart-service\nkubectl -n ecommerce-prod describe pod <pod>\nkubectl -n ecommerce-prod logs <pod> --previous\n`\nЕсли rollout завис, см. RB-2025-06.\n\n# Миграции\nКритично: миграции должны ходить в primary Postgres, не через PgBouncer (ADR-2024-08, PM-2025-07).\nЕсли деплой добавляет колонку, и миграция не выполнилась, получите UndefinedColumn и CrashLoop.\n\n# Observability\n- /metrics для Prometheus\n- X-Request-Id в логах\n\nМинимальные дашборды после деплоя:\n- latency + 5xx\n- Postgres numbackends\n- Redis evicted_keys (если трогали кеш)\n- Stripe webhook queue (если трогали payment-gateway)\n- ES health (если трогали search)\n\n# Грабли\n- Partial rollout секретов Stripe: часть подов валит invalid_signature\n- Смена формата Redis ключей: резкий cache miss и рост нагрузки на БД\n- Алиас products_read отсутствует: search-api уходит в 503\n\n# Локальный k8s (опционально)\nkind:\n`bash\nkind create cluster --name ecommerce-dev\nkubectl create ns ecommerce-dev\nkubectl -n ecommerce-dev apply -f infra/k8s/dev/\n`\nЕсли ImagePull проблемы, загрузите локальный образ в kind.\n\n# Рекомендация по rollback\nЕсли после деплоя сразу пошел всплеск 5xx, rollback первым действием, дебаг вторым.\n`bash\nkubectl -n ecommerce-prod rollout undo deploy/checkout-service\n`\n\n# Ссылки\n- CL-2025-09 прод-чеклист\n- RB-2024-11 Postgres connections\n- RB-2026-02 Redis eviction\n- RB-2026-01 Stripe webhook backlog"
    },
    {
      "doc_id": "api-2025-11-cart-v1",
      "title": "API Spec: cart-service Public API (v1)",
      "document_type": "api_spec",
      "created_at": "2025-11-10",
      "content": "# Обзор\ncart-service владеет состоянием корзины. Postgres — источник истины. Redis — кеш производительности (ADR-2025-03). При падении кеша API должно работать (дороже по latency).\n\nBase path: /api/cart\nAuth: Bearer JWT\nИдемпотентность: обязательна на мутациях (Idempotency-Key)\nКонкурентность: optimistic через If-Match (ETag)\n\n# Заголовки\nRequest:\n- Authorization: Bearer <jwt>\n- Idempotency-Key: <uuid> (для POST/DELETE)\n- If-Match: W/<etag> (для мутаций)\n- X-Request-Id (опционально)\n\nResponse:\n- ETag: W/<etag>\n- X-Cache: hit|miss|bypass\n- X-Request-Id\n\n# Модель данных\nCart:\n- cart_id uuid\n- user_id uuid\n- version int\n- currency string (USD или EUR)\n- items array\n- totals subtotal_minor, tax_minor, total_minor\n- updated_at RFC3339\n\nCartItem:\n- sku string\n- qty int 1..99\n- unit_price_minor int\n- title optional\n\n# Формат ошибок\nЕдиный формат:\n`json\n{ 'error_code': 'CODE', 'message': 'text', 'request_id': '...' }\n`\n\nТиповые error_code:\n- CART_NOT_FOUND (404)\n- ITEM_NOT_FOUND (404)\n- INVALID_QTY (422)\n- INVALID_SKU (422)\n- CART_VERSION_MISMATCH (409)\n- PRECONDITION_FAILED (412)\n- IDEMPOTENCY_KEY_REUSE (409)\n- RATE_LIMITED (429)\n\n# Endpoints\n## GET /api/cart/{user_id}\nВозвращает корзину. По умолчанию пустая корзина возвращается как 200 с пустым списком, а не 404.\nQuery:\n- include_empty bool default true\n\nОтвет 200 пример:\n`json\n{\n  'cart_id': '3b3b...',\n  'user_id': '9a9a...',\n  'version': 17,\n  'currency': 'USD',\n  'items': [{'sku': 'SKU-123', 'qty': 2, 'unit_price_minor': 1299}],\n  'totals': {'subtotal_minor': 2598, 'tax_minor': 182, 'total_minor': 2780},\n  'updated_at': '2025-11-02T10:12:30Z'\n}\n`\n\n## POST /api/cart/{user_id}/items\nДобавить или обновить qty.\nHeaders: Idempotency-Key обязателен, If-Match обязателен.\nBody:\n`json\n{ 'sku': 'SKU-123', 'qty': 3 }\n`\nОшибки:\n- 409 CART_VERSION_MISMATCH если ETag устарел\n- 412 PRECONDITION_FAILED если If-Match отсутствует\n- 422 INVALID_QTY/INVALID_SKU\n\nПоведение идемпотентности:\n- Повтор того же ключа с тем же payload должен вернуть тот же результат.\n- Повтор того же ключа с другим payload -> 409 IDEMPOTENCY_KEY_REUSE.\n\n## DELETE /api/cart/{user_id}/items/{sku}\nУдалить позицию.\nHeaders: Idempotency-Key, If-Match обязательны.\nОшибки: 404 ITEM_NOT_FOUND.\n\n## POST /api/cart/{user_id}/clear\nОчистить корзину, version инкрементится.\nИспользуется UI и (опционально) checkout-service после успешного заказа.\n\n## GET /api/cart/{user_id}/items\nПагинация для аномально больших корзин (видели 500+ позиций из-за злоупотреблений API).\nQuery:\n- page_size int default 100 max 200\n- cursor string\nResponse:\n- items\n- next_cursor\n\n# Идемпотентность (внутри)\nПо умолчанию ключи храним в Redis:\n- idem:cart:<user_id>:<key> TTL 24h\nЕсли Redis недоступен, fallback на таблицу Postgres idempotency_keys.\n\n# Нюансы\n- qty=0 не принимаем, удаление только через DELETE. Раньше некоторые клиенты пытались использовать 0, это создавало тихие рассинхроны.\n- Unit price может устареть, финальный пересчет делает checkout-service (иначе PRICE_CHANGED).\n- Redis eviction может повышать mismatch rate, особенно если ETag считался из кешированного payload. Смотри RB-2026-02 и PM-2025-11.\n\n# Changelog\nv1.6 (2025-10) добавили /clear\nv1.7 (2025-11) добавили IDEMPOTENCY_KEY_REUSE"
    },
    {
      "doc_id": "api-2025-11-checkout-v2",
      "title": "API Spec: checkout-service Public API (v2)",
      "document_type": "api_spec",
      "created_at": "2025-11-18",
      "content": "# Обзор\ncheckout-service оркестрирует оформление заказа, создает order/payment в Postgres и инициирует платеж через payment-gateway. Финализация платежа идет по webhooks (ADR-2024-12).\n\nBase path: /api/checkout\nAuth: Bearer JWT\nИдемпотентность: обязательна для /start и refund\n\n# Заголовки\nRequest:\n- Authorization: Bearer <jwt>\n- Idempotency-Key: <uuid> (обязателен для /start)\n- X-Request-Id опционально\n\nResponse:\n- X-Request-Id\n- Retry-After иногда при 503\n\n# Формат ошибок\n`json\n{ 'error_code': 'CODE', 'message': 'text', 'request_id': '...' }\n`\nКоды:\n- CART_VERSION_MISMATCH (409)\n- PRICE_CHANGED (409)\n- ADDRESS_INVALID (422)\n- PAYMENT_PROVIDER_UNAVAILABLE (503)\n- PAYMENT_PENDING_TIMEOUT (409)\n- ORDER_NOT_FOUND (404)\n- ORDER_ALREADY_PAID (409)\n- IDEMPOTENCY_KEY_REUSE (409)\n\n# Статусы\norders.status: PAYMENT_PENDING, PAID, FULFILLING, FULFILLED, PAYMENT_FAILED, CANCELLED\npayments.payment_status: PENDING, SUCCEEDED, FAILED, CANCELED, REFUNDED\n\n# Endpoints\n## POST /api/checkout/start\nСоздает заказ и возвращает client_secret.\nBody:\n`json\n{\n  'user_id': 'uuid',\n  'cart_id': 'uuid',\n  'shipping_address_id': 'uuid',\n  'billing_address_id': 'uuid',\n  'currency': 'USD'\n}\n`\n\nШаги:\n1) Вызывает cart-service GET /api/cart/{user_id} и проверяет If-Match семантику (ETag).\n2) Делает пересчет цен (локально, без внешнего pricing сервиса).\n3) В транзакции пишет orders и payments.\n4) Дергает payment-gateway internal endpoint, создает PaymentIntent.\n\nОтвет 201:\n`json\n{\n  'order_id': 'uuid',\n  'status': 'PAYMENT_PENDING',\n  'payment': {\n    'provider': 'stripe',\n    'payment_intent_id': 'pi_...',\n    'client_secret': 'pi_..._secret_...'\n  }\n}\n`\n\nОшибки:\n- 409 CART_VERSION_MISMATCH если корзина изменилась\n- 409 PRICE_CHANGED если пересчет дал другие totals\n- 503 PAYMENT_PROVIDER_UNAVAILABLE если payment-gateway недоступен\n\nНюанс: если payment-gateway таймаутит, но успел создать PaymentIntent, повтор с тем же Idempotency-Key должен вернуть тот же intent. Если это ломается, будет дубль intent.\n\n## GET /api/checkout/orders/{order_id}\nПолные детали заказа и платежа.\n\n## GET /api/checkout/orders/{order_id}/status\nЛегкий endpoint для UI polling:\n`json\n{ 'order_id': '...', 'status': 'PAYMENT_PENDING', 'payment_status': 'PENDING' }\n`\nКешируется на edge 2 секунды, не использовать как источник корректности.\n\n## POST /api/checkout/orders/{order_id}/cancel\nОтмена неоплаченного заказа.\nПравила:\n- если payment_status=SUCCEEDED -> 409 ORDER_ALREADY_PAID\n- если pending старше 10 минут, отмена разрешена\n\n## POST /api/checkout/orders/{order_id}/refund\nАсинхронный возврат (обычно support tooling). Требует elevated scope.\nHeaders: Idempotency-Key обязателен.\nBody:\n`json\n{ 'amount_minor': 2780, 'reason': 'customer_request' }\n`\nОтвет: 202 accepted.\n\n# Идемпотентность\n- Для /start ключ хранится в таблице checkout_idempotency с unique (user_id, key).\n- Повтор с другим cart_id/address_id -> IDEMPOTENCY_KEY_REUSE.\n\n# Observability\nМетрики:\n- checkout_start_total\n- checkout_cart_mismatch_total\n- payment_provider_errors_total\n- orders_payment_pending_total\n\nЛоги:\n- order_id, user_id, cart_id, provider_payment_id, request_id\n\n# Edge cases\n- Pending слишком долго: UI может предложить поддержку, backend может вернуть PAYMENT_PENDING_TIMEOUT\n- Out-of-order Stripe события: успех может прийти после cancel. Тогда политика: предпочитать SUCCEEDED и затем инициировать refund, если нужно.\n- Currency mismatch: если валюта корзины не совпала с запросом, возвращаем 422 CURRENCY_MISMATCH\n- 304 от cart-service: checkout-service не должен доверять только UI totals, должен сверить со снапшотом\n\n# Связанные документы\n- ADR-2024-12\n- RB-2026-01\n- OB-2025-04"
    },
    {
      "doc_id": "api-2025-11-search-v3",
      "title": "API Spec: search-api Public API (v3)",
      "document_type": "api_spec",
      "created_at": "2025-11-22",
      "content": "# Обзор\nsearch-api предоставляет поиск товаров поверх Elasticsearch. Индексы меняются через алиасы (ADR-2025-02). Во время reindex результаты могут слегка отличаться, но контракт API стабилен.\n\nBase path: /api/search\nAuth: опционально (анонимный поиск разрешен), JWT нужен для персонализации\n\n# Заголовки\nRequest:\n- X-Request-Id (опционально)\n- Accept-Language (опционально)\n\nResponse:\n- X-Request-Id\n- X-Search-Degraded: true|false\n\n# Ошибки\n`json\n{ 'error_code': 'CODE', 'message': 'text', 'request_id': '...' }\n`\nКоды:\n- INVALID_FILTER (400)\n- INVALID_SORT (400)\n- SEARCH_UNAVAILABLE (503)\n- SEARCH_RATE_LIMITED (429)\n\n# Endpoints\n## GET /api/search/products\nQuery:\n- q string (пусто = trending)\n- page int default 1\n- page_size int default 24 max 100\n- filters repeatable key:value (brand, category, price_min, price_max, in_stock)\n- sort relevance|price_asc|price_desc|newest\n- include_facets bool default true\n\nОтвет 200:\n`json\n{\n  'total': 1234,\n  'page': 1,\n  'page_size': 24,\n  'results': [\n    { 'sku': 'SKU-123', 'title': 'Sneaker X', 'price_minor': 1299, 'currency': 'USD', 'score': 12.3 }\n  ],\n  'facets': {\n    'brand': [{'value': 'acme', 'count': 120}],\n    'category': [{'value': 'shoes', 'count': 900}]\n  }\n}\n`\n\n## GET /api/search/suggest\nQuery:\n- q required\n- limit default 8 max 20\nОтвет:\n`json\n{ 'suggestions': ['sneakers', 'sneaker cleaner'] }\n`\n\n# Таймауты\nElasticsearch client:\n- connect 50мс\n- request 150мс\nРетраи отключены, чтобы не усиливать перегруз. Если ES отвечает 429, мы возвращаем 503 SEARCH_UNAVAILABLE с retry_after_seconds=2.\n\n# Degraded mode\nПри перегрузе ES или health yellow/red:\n- SEARCH_ENABLE_AGGS=false (убираем facets)\n- SEARCH_ENABLE_SPELLCHECK=false\n- SEARCH_MAX_CONCURRENCY=40\n\nТогда:\n- facets отсутствуют\n- X-Search-Degraded=true\n\n# Алиасы\nЧитаем из products_read.\nЕсли алиас отсутствует или указывает на удаленный индекс, ES вернет index_not_found_exception, search-api отдаст 503.\n\n# Нюансы\n- q пустой: trending кешируется на 60с\n- неизвестный filter key: 400 INVALID_FILTER\n- Accept-Language неподдерживаемый: используем default analyzer\n- facets во время dual-write могут быть неидеальны, это допустимо\n\n# Rate limit\nНа edge:\n- 60 rpm на IP для /products\n- 120 rpm на IP для /suggest\nПри лимите: 429 SEARCH_RATE_LIMITED, Retry-After: 5\n\n# Observability\n- search_requests_total\n- search_latency_seconds_bucket\n- es_rejections_total\n- search_degraded_mode_enabled (gauge)\n\n# Примеры\n`bash\ncurl 'https://api.company.tld/api/search/products?q=sneakers&page=1&page_size=24&filters=brand:acme&sort=relevance'\ncurl 'https://api.company.tld/api/search/suggest?q=snea&limit=8'\n`\n\n# Связанные документы\n- ADR-2025-02\n- RB-2025-12\n- CL-2025-10"
    },
    {
      "doc_id": "pm-2025-11-redis-evictions",
      "title": "Постмортем PM-2025-11: Redis eviction привел к ошибкам чекаута",
      "document_type": "postmortem",
      "created_at": "2025-11-30",
      "content": "# Summary\n2025-11-29 Redis в ecommerce-prod вошел в режим устойчивого memory pressure, начались интенсивные eviction и скачки latency команд. Так как cart-service активно использует Redis (ADR-2025-03), а checkout-service опирается на ETag/If-Match для согласованности, eviction шторм вызвал всплеск 409 CART_VERSION_MISMATCH и 412 PRECONDITION_FAILED на /api/checkout/start.\n\nДанные корзины не потеряны (источник истины Postgres), но конверсия просела примерно на 47 минут.\n\n# Impact\n- 2025-11-29 09:12–09:59 UTC\n- 12.4 процента запросов /api/checkout/start вернули 409/412\n- p95 checkout вырос с 220мс до 780мс\n- p95 cart-service вырос с 120мс до 410мс\n\n# Detection\nСработали алерты RedisEvictionsHigh и CartVersionMismatchSpike.\nНа дашборде Redis было видно used_memory почти равен maxmemory (18GB), evicted_keys рос.\n\n# Timeline\n- 09:12 алерт на eviction\n- 09:16 рост 409/412 и жалобы продукта\n- 09:22 включили CART_CACHE_BYPASS=true и отключили writeback\n- 09:26 Postgres нагрузка выросла, но удержалась < 75 процентов CPU\n- 09:31 удалили часть oversized ключей (как крайняя мера)\n- 09:38 подготовили hotfix по payload\n- 09:45 постепенно включили кеш обратно\n- 09:59 метрики вернулись к норме\n\n# Root cause\nУтром релизнули фичу рекомендаций в корзине. Реализация сохранила расширенные рекомендации прямо в кешированный payload корзины. Средний размер значения cart:* вырос примерно в 6 раз (с ~30КБ до ~180КБ, p95 > 220КБ).\n\nRedis policy allkeys-lfu не смог спасти ситуацию при упоре в maxmemory: ключи выкидывались и сразу создавались заново. Дополнительно на части путей TTL выставлялся без джиттера, что синхронизировало истечения.\n\nВажно: ETag вычислялся из кешированного payload в одном из путей (особенно при rehydrate), поэтому churn усиливал mismatch.\n\n# Contributing factors\n- Не было лимита размера кешируемого payload\n- Нагрузочные тесты не включали shape рекомендаций\n- TTL jitter применялся не везде\n- checkout-service не делал retry на mismatch (считал 409 фатальным)\n\n# Resolution\n- Временно bypass Redis для чтения корзины\n- Частичная ручная чистка oversized ключей\n- Hotfix: хранить в кеше только sku рекомендаций, не весь объект\n- Постепенное возвращение кеша\n\n# Что было хорошо\n- Фича-флаг CART_CACHE_BYPASS уже существовал\n- PgBouncer защитил Postgres от коллапса при росте read load\n\n# Что было плохо\n- Оптимизация производительности превратилась в correctness-adjacent проблему\n- Не было мониторинга по размеру значений\n\n# Action items\n1) Ввести CART_CACHE_MAX_BYTES=131072 и пропуск кеширования при превышении\n2) Добавить метрику cart_cache_value_size_bytes (p50/p95) и алерт\n3) Протестировать TTL jitter единообразно, покрыть unit тестом\n4) Добавить в checkout-service одноразовый retry на CART_VERSION_MISMATCH\n5) Дополнить ADR-2025-03 запретом кешировать expanded metadata\n\n# Противоречие с ADR\nADR-2025-03 предполагала, что Redis влияет только на latency и Postgres является fallback. На практике eviction шторм поднял mismatch и ударил по чекауту. Это не означает, что Redis нельзя использовать, но означает, что нельзя кешировать тяжелые payload и нельзя строить ETag на нестабильном представлении.\n\n# Ссылки\n- ADR-2025-03\n- RB-2026-02"
    },
    {
      "doc_id": "pm-2025-07-schema-drift",
      "title": "Постмортем PM-2025-07: деплой checkout-service сломался из-за не примененной миграции",
      "document_type": "postmortem",
      "created_at": "2025-07-19",
      "content": "# Summary\n2025-07-18 задеплоили checkout-service v2.9.0, который ожидал колонку orders.applied_promotions. Миграция Alembic не применилась (джоба упала), но promote пайплайн не зафейлился. Новые поды начали отдавать 500 с UndefinedColumn.\n\n# Impact\n- 2025-07-18 14:03–14:24 UTC\n- POST /api/checkout/start: ~68 процентов 500\n- GET /api/checkout/orders/{id}: 500 для заказов, созданных в окне\n\n# Detection\n- Checkout5xxSpike\n- Логи: psycopg.errors.UndefinedColumn: column orders.applied_promotions does not exist\n\n# Timeline\n- 14:03 promote завершился\n- 14:05 алерт\n- 14:10 откат на v2.8.3\n- 14:18 ручной запуск миграции\n- 14:24 стабилизация\n\n# Root cause\nМиграционная джоба использовала application DATABASE_URL, который указывает на PgBouncer. PgBouncer работает в transaction pooling (ADR-2024-08). Миграция использовала advisory lock и ожидала session-level стабильность. Джоба завершилась с non-zero.\n\nДальше два усугубляющих решения:\n- шаг миграции в promote был continue-on-error=true\n- не было проверки что alembic head действительно применен\n\nВ итоге деплой продолжился, код начал обращаться к несуществующей колонке.\n\n# Contributing factors\n- В staging миграции ходили напрямую в primary, поэтому проблему не поймали.\n- Логи миграции не отображались в сводке promote.\n- Не было preflight проверки схемы.\n\n# Resolution\n- Откат rollout\n- Ручной запуск миграций против primary Postgres:\n`bash\nkubectl -n ecommerce-prod create job --from=cronjob/checkout-migrations checkout-migrations-manual\nkubectl -n ecommerce-prod logs job/checkout-migrations-manual\n`\n- Проверка наличия колонки:\n`sql\nselect column_name from information_schema.columns where table_name='orders' and column_name='applied_promotions';\n`\n\n# Что было хорошо\n- Откат прошел быстро\n- Диагноз был очевиден по логам\n\n# Что было плохо\n- Пайплайн скрывал ошибку миграции\n- Нарушили собственную ADR про миграции мимо PgBouncer\n\n# Action items\n1) Убрать continue-on-error из миграционного шага\n2) Добавить gate: alembic current == head\n3) Ввести DATABASE_URL_PRIMARY для миграций во всех средах\n4) Добавить в promote вывод логов миграций в summary\n5) Обновить онбординг CI/CD и чеклист прод-деплоя\n\n# Нюанс\nИногда миграции случайно проходят через PgBouncer и кажется что это работает. Но любая миграция, зависящая от session state, может падать нестабильно. Дебаг такого поведения дороже, чем явное правило: миграции всегда через primary.\n\n# Ссылки\n- ADR-2024-08\n- RB-2025-06"
    },
    {
      "doc_id": "pm-2025-08-duplicate-fulfillment",
      "title": "Постмортем PM-2025-08: ретраи Stripe webhooks привели к дубликатам отгрузки",
      "document_type": "postmortem",
      "created_at": "2025-08-10",
      "content": "# Summary\n2025-08-09 краткая нестабильность payment-gateway привела к ретраям Stripe webhooks. Входящие Stripe события были идемпотентны по event_id, но downstream consumer fulfillment-dispatcher оказался не идемпотентен по нашему internal событию orders.paid. В результате часть заказов ушла в отгрузку дважды.\n\nВажно: клиентов не списало дважды, проблема была в логистике и нотификациях.\n\n# Impact\n- 2025-08-09 16:22–16:41 UTC\n- 183 заказа получили duplicate dispatch\n- 61 дубль shipping label\n- 9 упаковок начали готовить дважды, остановили до pickup\n\n# Detection\n- FulfillmentDuplicateDispatchSpike\n- тикеты поддержки: два трек-номера\n- алерт на рост 5xx по /webhooks/stripe и рост stripe_webhook_queue_depth\n\n# Timeline\n- 16:22 payment-gateway рестартится (OOMKilled)\n- 16:24 Stripe ретраит payment_intent.succeeded\n- 16:26 payment-gateway восстановился\n- 16:31 dispatcher отправляет заказы, появляются дубли\n- 16:34 oncall паузит fulfillment-dispatcher\n- 16:37 запускаем скрипт дедупликации\n- 16:41 стабилизация\n\n# Root cause\nДве проблемы:\n1) В payment-gateway был включен флаг LOG_WEBHOOK_PAYLOADS=true (оставили после отладки). Логирование полного payload на INFO привело к росту памяти и OOMKilled.\n2) Внутренняя цепочка transitions не была полностью идемпотентна. Один воркер обработал событие и поставил payment_status=SUCCEEDED, второй воркер повторно прошел путь после transient DB timeout и повторно эмитнул orders.paid, потому что не было уникального ограничения на (order_id, transition).\n\nfulfillment-dispatcher предполагал exactly-once и не проверял уникальность order_id при dispatch.\n\n# Resolution\nСразу:\n- scale fulfillment-dispatcher в 0\n- отмена дублей в warehouse API\n- hotfix checkout-service: эмитить orders.paid только если update реально меняет payment_status\n\nСтабилизация:\n- отключили LOG_WEBHOOK_PAYLOADS и перезадеплоили payment-gateway\n- временно снизили WEBHOOK_MAX_CONCURRENCY\n\n# Corrective actions\n1) Добавить unique constraint:\n`sql\nalter table order_transitions add constraint order_transition_unique unique (order_id, transition_name);\n`\n2) Сделать fulfillment-dispatcher идемпотентным:\n- unique по order_id\n- при дубле логировать и ack без действий\n3) Добавить алерт на OOMKilled payment-gateway\n4) Обновить RB-2026-01 предупреждением про payload logging\n5) Ввести правило в гайдлайнах: все consumers должны предполагать at-least-once\n\n# Что было хорошо\n- Быстро остановили downstream и ограничили радиус\n- Stripe ingestion не создал двойных списаний\n\n# Что было плохо\n- Debug флаги не отделены от прод-настроек\n- Идемпотентность была неполной (внутренние события)\n\n# Дополнительное противоречие\nADR-2024-12 делал ставку на вебхуки. После этого инцидента обсуждался fallback поллинг для VIP заказов. Это НЕ принято как стандартный путь, но появился экспериментальный флаг PAYMENTS_FORCE_POLLING_FALLBACK (включать только по согласованию, иначе можно усугубить 429 на Stripe).\n\n# Ссылки\n- ADR-2024-12\n- RB-2026-01\n- OB-2025-04"
    },
    {
      "doc_id": "cl-2025-09-prod-deploy",
      "title": "Операционный чеклист CL-2025-09: прод-деплой core сервисов",
      "document_type": "checklist",
      "created_at": "2025-09-01",
      "content": "# Назначение\nЧеклист для промоута релизов в прод для checkout-service, cart-service, search-api, payment-gateway. Он строгий, потому что большинство аварий было из-за мелочей: env vars, миграции, формат кеша.\n\n# Перед promote\n1) Артефакт\n- определить SHA образа и релиз-ноты\n- убедиться, что staging крутит тот же образ\n- CI прошел на merge commit\n\n2) Просмотреть diff на острые темы\n- миграции alembic\n- Redis ключи/сериализация\n- ES mapping/template\n- Stripe webhook изменения\n- новые env переменные (pydantic Settings)\n\n3) Миграции\n- миграционная джоба должна использовать primary Postgres, не PgBouncer\n- в staging: alembic current == head\n- если миграция тяжелая (индексы на больших таблицах), планировать off-peak или pre-run\n\n4) План отката\nВ issue записать:\n- на какой образ откатываемся\n- кто делает rollback\n- какой сигнал будет триггером отката (например 5xx spike, конверсия, алерты)\n\n# Во время promote\n5) Запуск\n- использовать promote workflow, не kubectl apply руками\n\n6) Мониторить rollout\n`bash\nkubectl -n ecommerce-prod rollout status deploy/<service>\nkubectl -n ecommerce-prod get pods -l app=<service>\n`\nЕсли > 5 минут зависло, см. RB-2025-06.\n\n7) Мониторить дашборды 15 минут\nМинимум:\n- latency и 4xx/5xx\n- Postgres numbackends\n- Redis evicted_keys (если трогали кеш)\n- Stripe webhook queue (если трогали payment-gateway)\n- ES health (если трогали search)\n\n8) Smoke тесты\n- корзина: add/remove + refresh, проверить что не пошли неожиданные 409\n- чекаут: /api/checkout/start с Idempotency-Key, повтор тем же ключом возвращает тот же order_id\n- поиск: базовый запрос, facets (если не degraded)\n- платежи: в staging тестовый платеж и проверить stripe_events\n\n# После деплоя\n9) Error budget\nЕсли burn ускорился, даже при малых абсолютных 5xx, остановиться и расследовать.\n\n10) Логи\nИскать:\n- ValidationError\n- UndefinedColumn\n- redis.exceptions\n- StripeSignatureVerificationError\n- index_not_found_exception\n\n11) Изменения вокруг Redis\nЕсли меняли кеш корзины:\n- наблюдать размеры payload и eviction минимум 30 минут\n- быть готовым включить CART_CACHE_BYPASS (RB-2026-02)\n\n# Экстренный rollback\nОткат если:\n- 5xx скачок сразу после релиза\n- просела конверсия чекаута\n- сломалась проверка подписи вебхуков\n- schema mismatch\n\nКоманды:\n`bash\nkubectl -n ecommerce-prod rollout undo deploy/checkout-service\nkubectl -n ecommerce-prod rollout undo deploy/cart-service\nkubectl -n ecommerce-prod rollout undo deploy/search-api\nkubectl -n ecommerce-prod rollout undo deploy/payment-gateway\n`\n\n# Примечания\n- Не включать LOG_WEBHOOK_PAYLOADS в прод без явного согласования (PM-2025-08)\n- Feature flag подход предпочтителен для рискованных изменений\n- Partial rollout секретов Stripe недопустим: при ротации нужно быстро прокрутить все поды"
    },
    {
      "doc_id": "cl-2025-10-weekly-ops",
      "title": "Операционный чеклист CL-2025-10: еженедельные проверки платформы",
      "document_type": "checklist",
      "created_at": "2025-10-06",
      "content": "# Назначение\nПрофилактический чеклист (45–60 минут) чтобы ловить медленные деградации: диски, очереди, ретеншн, коннекты, секреты. Это не инцидентный процесс.\n\n# 1) Postgres\n- проверить количество коннектов и долгие запросы\n`sql\nselect count(*) from pg_stat_activity;\nselect pid, now()-query_start as age, state, query\nfrom pg_stat_activity\nwhere state <> 'idle'\norder by age desc\nlimit 10;\n`\n- посмотреть bloat на cart_items и stripe_events, планировать maintenance если растет\n\n# 2) PgBouncer\n- убедиться, что сервисы ходят через PgBouncer (application_name и endpoint)\n- смотреть cl_waiting и sv_active\nЕсли видите много прямых подключений к primary, открыть тикет: это предвестник RB-2024-11.\n\n# 3) Redis\n- used_memory и eviction\n- размер payload корзины (cart_cache_value_size_bytes)\nЕсли eviction растет в обычном трафике:\n- подозрение на oversized values\n- отсутствие TTL jitter\n- внезапный рост трафика\n\nПримечание: Redis уже ломал чекаут (PM-2025-11).\n\n# 4) Elasticsearch\n- health green\n- диски ниже watermark\n- алиас products_read существует\n`bash\ncurl -s http://elasticsearch:9200/_cluster/health?pretty\ncurl -s http://elasticsearch:9200/_cat/aliases/products_read?v\ncurl -s http://elasticsearch:9200/_cat/indices/products-v3-*?h=index,store.size,docs.count&s=index\n`\nЕсли индексы старше 14 дней не удаляются, ILM сломан и это вопрос времени до disk watermark.\n\n# 5) Stripe webhooks\n- stripe_webhook_queue_depth на базовом уровне\n- stripe_signature_fail_total близко к 0\nЕсли signature failures > 0:\n- проверять partial rollout секретов\n- проверять ingress путь /webhooks/stripe\n\n# 6) Фоновые джобы\n- Kafka lag индексатора не растет неделями\n- refund-reconciler успешно отработал за 24ч\n- stripe-webhook-replay cronjob не запускается сам по себе\n\n# 7) Секреты и сертификаты\n- Stripe ключи ротируются раз в квартал\n- проверить, что после ротации все поды перезапущены (иначе интермиттентные ошибки)\n- проверить срок TLS сертификатов ingress\n\n# 8) Алерты и дашборды\n- топ шумных алертов, убрать флап\n- убедиться, что панели Grafana не ссылаются на удаленные метрики\n\n# 9) CI/CD и registry\n- нет очередей GitHub Actions\n- последний промоутнутый SHA существует в registry\n- ретеншн registry чистит старые sha теги\n\n# 10) SLO\n- недельный error budget burn для checkout-service и payment-gateway\nЕсли > 30 процентов за неделю, открыть reliability тикет даже без SEV инцидента.\n\n# Выход\nСоздать weekly ops тикет:\n- что проверили\n- что нашли\n- какие тикеты открыли\n\n# Ссылки\n- RB-2024-11, RB-2025-06, RB-2025-12, RB-2026-01, RB-2026-02\n- ADR-2024-08, ADR-2025-02, ADR-2025-03"
    }
  ]
}